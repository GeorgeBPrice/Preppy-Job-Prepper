export default [
  {
    id: 'typescript-basics',
    title: 'TypeScript Basics',
    questions: [
      {
        text: 'What is TypeScript and what are its main benefits when used with React?',
        answer:
          'TypeScript is a statically typed superset of JavaScript that compiles to plain JavaScript. Its main benefits when used with React include:<br><br>1. <strong>Static type checking:</strong> Catches type-related errors during development instead of runtime<br>2. <strong>Enhanced IDE support:</strong> Provides better autocomplete, navigation, and refactoring tools<br>3. <strong>Self-documenting code:</strong> Types serve as documentation for component props and state<br>4. <strong>Type inference:</strong> TypeScript can often determine types automatically, reducing boilerplate<br>5. <strong>Safer refactoring:</strong> Changing component interfaces shows immediate type errors<br>6. <strong>Better team collaboration:</strong> Clear contracts between components improve maintainability<br>7. <strong>Improved debugging experience:</strong> Type information helps during debugging sessions<br>8. <strong>Rich ecosystem:</strong> Most React libraries provide TypeScript definitions',
      },
      {
        text: "What is the difference between 'interface' and 'type' in TypeScript?",
        answer:
          'While both <code>interface</code> and <code>type</code> can be used to define object shapes in TypeScript, they have some key differences:<br><br>1. <strong>Declaration merging:</strong> Interfaces can be declared multiple times and will merge, while types cannot<br><code>interface User { name: string; }<br>interface User { age: number; }<br>// Becomes: interface User { name: string; age: number; }</code><br><br>2. <strong>Extends vs intersection:</strong> Interfaces use <code>extends</code>, types use <code>&</code> (intersection)<br><code>interface UserWithRole extends User { role: string; }<br>type UserWithRole = User & { role: string; }</code><br><br>3. <strong>Primitive types:</strong> Type aliases can directly represent primitives, unions, and tuples<br><code>type ID = string | number;<br>type Point = [number, number];</code><br><br>4. <strong>Computed properties:</strong> Types support mapped and conditional types<br><code>type ReadOnly<T> = { readonly [P in keyof T]: T[P] };</code><br><br>5. <strong>Advanced features:</strong> Types support more advanced features like conditional types<br><code>type ExtractId<T> = T extends { id: infer U } ? U : never;</code><br><br>In React, interfaces are generally preferred for public API definitions (like component props), while types are often used for complex transformations, unions, and internal types. Use interfaces when you want to define a contract that others might extend, and types when you need more flexibility.',
      },
      {
        text: 'What are union and intersection types in TypeScript?',
        answer:
          "Union and intersection types are powerful TypeScript features for combining types:<br><br><strong>Union Types (|):</strong><br>Union types allow a value to be one of several types. They're created using the pipe symbol.<br><code>type ID = string | number; // ID can be either string or number<br>type Status = 'loading' | 'success' | 'error'; // String literal union</code><br><br>Common uses in React:<br>- Component props that accept different value types<br>- Discriminated unions for state management<br>- Handling nullable values with <code>type Nullable<T> = T | null | undefined</code><br><br><strong>Intersection Types (&):</strong><br>Intersection types combine multiple types into one. They're created using the ampersand symbol.<br><code>interface NameInfo { name: string; }<br>interface AgeInfo { age: number; }<br>type Person = NameInfo & AgeInfo; // Has both name and age</code><br><br>Common uses in React:<br>- Extending props interfaces without inheritance<br>- Creating mixins of behaviors<br>- Combining multiple state slices<br><code>type ButtonProps = BaseButtonProps & (LinkButtonProps | ActionButtonProps);</code><br><br><strong>Key Differences:</strong><br>- Union (|): value can be either type (OR)<br>- Intersection (&): value has properties of all types (AND)<br><br>Using union types requires narrowing (type guards) to access type-specific properties, while intersection types immediately allow access to all properties of the combined types.",
      },
      {
        text: 'How do type assertions and type guards work in TypeScript?',
        answer:
          "Type assertions and type guards help TypeScript understand type information in specific contexts:<br><br><strong>Type Assertions:</strong><br>Type assertions tell the compiler to treat a value as a specific type, overriding its inference. There are two syntaxes:<br><code>// Angle bracket syntax (not used in TSX files)<br>const value = &lt;string&gt;someValue;<br><br>// as syntax (preferred, works in TSX)<br>const value = someValue as string;</code><br><br>Use cases:<br>- Asserting DOM element types<br><code>const input = document.getElementById('input') as HTMLInputElement;</code><br>- Working with unknown API responses<br><code>const user = JSON.parse(data) as User;</code><br>- Narrowing types when TypeScript can't determine them<br><br>Note: Type assertions don't change the runtime type or perform any checksâ€”they only affect the compiler's understanding.<br><br><strong>Type Guards:</strong><br>Type guards are expressions that perform a runtime check to guarantee a type in a certain scope. Common type guards include:<br><br>1. <strong>typeof</strong> for primitive types:<br><code>if (typeof value === 'string') {<br>  // value is treated as string here<br>}</code><br><br>2. <strong>instanceof</strong> for classes:<br><code>if (error instanceof ApiError) {<br>  // error is treated as ApiError here<br>}</code><br><br>3. <strong>in</strong> for property checks:<br><code>if ('name' in obj) {<br>  // obj is treated as having a name property<br>}</code><br><br>4. <strong>User-defined type guards</strong> with type predicates:<br><code>function isUser(obj: any): obj is User {<br>  return 'name' in obj && 'email' in obj;<br>}<br><br>if (isUser(data)) {<br>  // data is treated as User here<br>}</code><br><br>5. <strong>Discriminated unions</strong> for complex type narrowing:<br><code>type Action =<br>  | { type: 'INCREMENT'; amount: number }<br>  | { type: 'DECREMENT'; amount: number };<br><br>function reducer(state: number, action: Action) {<br>  switch (action.type) {<br>    case 'INCREMENT':<br>      // action is treated as { type: 'INCREMENT'; amount: number }<br>      return state + action.amount;<br>    case 'DECREMENT':<br>      // action is treated as { type: 'DECREMENT'; amount: number }<br>      return state - action.amount;<br>  }<br>}</code>",
      },
      {
        text: 'What are generics in TypeScript and when would you use them in React?',
        answer:
          "Generics in TypeScript are a way to create reusable components that can work with a variety of types while maintaining type safety. They allow you to define placeholders for types that are specified later:<br><br><strong>Basic syntax:</strong><br><code>function identity&lt;T&gt;(arg: T): T {<br>  return arg;<br>}</code><br><br><strong>Common uses in React:</strong><br><br>1. <strong>Generic Components</strong> that work with different data types:<br><code>interface ListProps&lt;T&gt; {<br>  items: T[];<br>  renderItem: (item: T) => React.ReactNode;<br>}<br><br>function List&lt;T&gt;({ items, renderItem }: ListProps&lt;T&gt;) {<br>  return (<br>    &lt;ul&gt;<br>      {items.map((item, index) => (<br>        &lt;li key={index}&gt;{renderItem(item)}&lt;/li&gt;<br>      ))}<br>    &lt;/ul&gt;<br>  );<br>}</code><br><br>2. <strong>Custom Hooks</strong> that handle different data types:<br><code>function useLocalStorage&lt;T&gt;(key: string, initialValue: T) {<br>  const [storedValue, setStoredValue] = useState&lt;T&gt;(() => {<br>    try {<br>      const item = window.localStorage.getItem(key);<br>      return item ? JSON.parse(item) : initialValue;<br>    } catch (error) {<br>      return initialValue;<br>    }<br>  });<br>  <br>  // Rest of implementation...<br>  <br>  return [storedValue, setValue] as const;<br>}</code><br><br>3. <strong>Type-safe API functions</strong>:<br><code>async function fetchData&lt;T&gt;(url: string): Promise&lt;T&gt; {<br>  const response = await fetch(url);<br>  return response.json();<br>}<br><br>// Usage:<br>const user = await fetchData&lt;User&gt;('/api/user/1');</code><br><br>4. <strong>State management</strong> with generics:<br><code>interface AsyncState&lt;T&gt; {<br>  data: T | null;<br>  loading: boolean;<br>  error: Error | null;<br>}</code><br><br>5. <strong>Generic context</strong> for flexible data sharing:<br><code>const DataContext = createContext&lt;T | null&gt;(null);</code><br><br>6. <strong>Higher-order components</strong> with proper typing:<br><code>function withLogging&lt;P extends object&gt;(Component: React.ComponentType&lt;P&gt;) {<br>  return function WithLogging(props: P) {<br>    useEffect(() => {<br>      console.log('Component rendered with props:', props);<br>    });<br>    <br>    return &lt;Component {...props} /&gt;;<br>  };<br>}</code><br><br>Generics are essential for building flexible, reusable, and type-safe abstractions in React applications, especially when the exact types aren't known until the component or function is used.",
      },
      {
        text: 'What are the different ways to declare variable types in TypeScript?',
        answer:
          "TypeScript offers several ways to declare variable types:<br><br>1. <strong>Explicit type annotations</strong>:<br><code>let name: string = 'John';<br>const age: number = 30;<br>let isActive: boolean = true;<br>let numbers: number[] = [1, 2, 3]; // Array of numbers<br>let tuple: [string, number] = ['John', 30]; // Tuple type</code><br><br>2. <strong>Type inference</strong> (letting TypeScript determine the type):<br><code>let name = 'John'; // TypeScript infers string type<br>const user = { id: 1, name: 'John' }; // Object with inferred properties</code><br><br>3. <strong>Union types</strong> for variables that can be multiple types:<br><code>let id: string | number; // Can be string or number<br>id = 101; // Valid<br>id = 'U101'; // Also valid</code><br><br>4. <strong>Type aliases</strong> for custom types:<br><code>type UserID = string | number;<br>let id: UserID = 'U123';</code><br><br>5. <strong>Interfaces</strong> for object shapes:<br><code>interface User {<br>  id: number;<br>  name: string;<br>  email?: string; // Optional property<br>}<br><br>const user: User = { id: 1, name: 'John' };</code><br><br>6. <strong>Enum types</strong> for named constants:<br><code>enum Role {<br>  Admin = 'ADMIN',<br>  User = 'USER',<br>  Guest = 'GUEST'<br>}<br><br>let userRole: Role = Role.Admin;</code><br><br>7. <strong>Any type</strong> (avoid when possible):<br><code>let data: any = fetchData(); // Can be anything</code><br><br>8. <strong>Unknown type</strong> (safer alternative to any):<br><code>let userInput: unknown = getUserInput();<br>// Requires type checking before use<br>if (typeof userInput === 'string') {<br>  console.log(userInput.toUpperCase());<br>}</code><br><br>9. <strong>Function types</strong>:<br><code>let greet: (name: string) => string;<br>greet = (name) => `Hello, ${name}!`;</code><br><br>10. <strong>Generic type parameters</strong>:<br><code>function identity&lt;T&gt;(value: T): T {<br>  return value;<br>}<br><br>let result = identity&lt;string&gt;('hello');</code><br><br>11. <strong>Index signatures</strong> for objects with dynamic keys:<br><code>interface Dictionary {<br>  [key: string]: string;<br>}<br><br>const colors: Dictionary = {<br>  red: '#ff0000',<br>  green: '#00ff00'<br>};</code><br><br>12. <strong>Intersection types</strong> to combine types:<br><code>type Employee = Person & { department: string };</code><br><br>In React, you'll commonly use interfaces for component props and state, union types for discriminated states, and generics for reusable components and hooks.",
      },
    ],
  },
  {
    id: 'typescript-with-react',
    title: 'TypeScript with React Components',
    questions: [
      {
        text: 'How do you type React functional components in TypeScript?',
        answer:
          "There are several ways to type React functional components in TypeScript:<br><br>1. <strong>React.FC / React.FunctionComponent</strong> (older approach):<br><code>import React from 'react';<br><br>interface GreetingProps {<br>  name: string;<br>}<br><br>const Greeting: React.FC&lt;GreetingProps&gt; = ({ name }) => {<br>  return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;<br>};</code><br><br>Pros:<br>- Implicitly includes children prop<br>- Explicitly shows the function is a React component<br><br>Cons:<br>- Children are always optional and typed as ReactNode<br>- Less flexible with generic components<br>- Doesn't allow for different return types<br><br>2. <strong>Function declaration with explicit props typing</strong> (recommended):<br><code>interface ButtonProps {<br>  label: string;<br>  onClick: () => void;<br>}<br><br>function Button({ label, onClick }: ButtonProps) {<br>  return &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;;<br>}</code><br><br>3. <strong>With explicit return type</strong>:<br><code>function Message({ text }: { text: string }): JSX.Element {<br>  return &lt;p&gt;{text}&lt;/p&gt;;<br>}</code><br><br>4. <strong>Generic components</strong>:<br><code>interface ListProps&lt;T&gt; {<br>  items: T[];<br>  renderItem: (item: T) => React.ReactNode;<br>}<br><br>function List&lt;T&gt;({ items, renderItem }: ListProps&lt;T&gt;) {<br>  return (<br>    &lt;ul&gt;<br>      {items.map((item, index) => (<br>        &lt;li key={index}&gt;{renderItem(item)}&lt;/li&gt;<br>      ))}<br>    &lt;/ul&gt;<br>  );<br>}</code><br><br>5. <strong>With children prop explicitly defined</strong>:<br><code>interface CardProps {<br>  title: string;<br>  children: React.ReactNode;<br>}<br><br>function Card({ title, children }: CardProps) {<br>  return (<br>    &lt;div className=\"card\"&gt;<br>      &lt;h2&gt;{title}&lt;/h2&gt;<br>      &lt;div&gt;{children}&lt;/div&gt;<br>    &lt;/div&gt;<br>  );<br>}</code><br><br>6. <strong>Arrow function with inline props</strong>:<br><code>const Input = ({ value, onChange }: { <br>  value: string; <br>  onChange: (value: string) => void<br>}) => {<br>  return (<br>    &lt;input<br>      value={value}<br>      onChange={(e) => onChange(e.target.value)}<br>    /&gt;<br>  );<br>};</code><br><br>The preferred approach in modern React with TypeScript is to use function declarations with explicit props interfaces rather than React.FC, as it offers more flexibility and avoids some pitfalls with typing children.",
      },
      {
        text: 'How do you handle component props with TypeScript, including optional and default props?',
        answer:
          "Handling props in TypeScript involves defining prop types and managing optional and default values:<br><br>1. <strong>Basic props interface</strong>:<br><code>interface ButtonProps {<br>  label: string;         // Required prop<br>  onClick: () => void;   // Required function prop<br>  variant?: 'primary' | 'secondary' | 'danger'; // Optional with specific values<br>  disabled?: boolean;    // Optional boolean prop<br>  size?: 'small' | 'medium' | 'large'; // Optional with union type<br>}</code><br><br>2. <strong>Optional props</strong> (using ? modifier):<br><code>interface UserProps {<br>  name: string;           // Required<br>  email?: string;         // Optional<br>  age?: number;           // Optional<br>}</code><br><br>3. <strong>Default values</strong> (using destructuring):<br><code>function Button({ <br>  label, <br>  onClick, <br>  variant = 'primary', // Default value<br>  disabled = false,     // Default value<br>  size = 'medium'       // Default value<br>}: ButtonProps) {<br>  return (<br>    &lt;button <br>      className={`btn btn-${variant} btn-${size}`}<br>      disabled={disabled}<br>      onClick={onClick}<br>    &gt;<br>      {label}<br>    &lt;/button&gt;<br>  );<br>}</code><br><br>4. <strong>Required vs Optional Pattern</strong>:<br><code>// Separate required and optional props<br>interface RequiredProps {<br>  value: string;<br>  onChange: (value: string) => void;<br>}<br><br>interface OptionalProps {<br>  placeholder?: string;<br>  disabled?: boolean;<br>  maxLength?: number;<br>}<br><br>// Combine them<br>type InputProps = RequiredProps & OptionalProps;<br><br>// Default values object<br>const defaultProps: OptionalProps = {<br>  placeholder: '',<br>  disabled: false<br>};<br><br>function Input(props: InputProps) {<br>  // Merge defaults with provided props<br>  const { value, onChange, placeholder, disabled, maxLength } = <br>    { ...defaultProps, ...props };<br>  <br>  return (/* component implementation */);  <br>}</code><br><br>5. <strong>React.ComponentProps</strong> for extending HTML element props:<br><code>interface ButtonProps extends React.ComponentProps&lt;'button'&gt; {<br>  variant?: 'primary' | 'secondary';<br>}<br><br>function Button({ variant = 'primary', className, ...rest }: ButtonProps) {<br>  return (<br>    &lt;button <br>      className={`btn-${variant} ${className || ''}`}<br>      {...rest}<br>    /&gt;<br>  );<br>}</code><br><br>6. <strong>Readonly props</strong> for immutability:<br><code>interface CardProps {<br>  readonly title: string;<br>  readonly content: string;<br>}</code><br><br>7. <strong>React's defaultProps</strong> (older approach, less common in modern React):<br><code>function Greeting({ name }: { name: string }) {<br>  return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;<br>}<br><br>Greeting.defaultProps = {<br>  name: 'Guest'<br>};</code><br><br>The recommended approach is to use destructuring with default values, as it's concise and keeps the defaults close to where the props are used.",
      },
      {
        text: 'How do you type event handlers in React with TypeScript?',
        answer:
          "Typing event handlers in React with TypeScript requires understanding the correct event types:<br><br>1. <strong>Basic event handler types</strong>:<br><code>// Button click handler<br>const handleClick = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) => {<br>  console.log('Button clicked', event.currentTarget.name);<br>};<br><br>// Input change handler<br>const handleChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {<br>  console.log('Input value:', event.target.value);<br>};<br><br>// Form submit handler<br>const handleSubmit = (event: React.FormEvent&lt;HTMLFormElement&gt;) => {<br>  event.preventDefault();<br>  console.log('Form submitted');<br>};</code><br><br>2. <strong>Common event types</strong>:<br>- <code>React.MouseEvent&lt;T&gt;</code>: For mouse events (click, mousedown, etc.)<br>- <code>React.ChangeEvent&lt;T&gt;</code>: For form element changes<br>- <code>React.FormEvent&lt;T&gt;</code>: For form submissions<br>- <code>React.KeyboardEvent&lt;T&gt;</code>: For keyboard events<br>- <code>React.FocusEvent&lt;T&gt;</code>: For focus/blur events<br>- <code>React.DragEvent&lt;T&gt;</code>: For drag and drop events<br>- <code>React.TouchEvent&lt;T&gt;</code>: For touch events<br>- <code>React.ClipboardEvent&lt;T&gt;</code>: For clipboard events<br><br>3. <strong>Event handlers in component props</strong>:<br><code>interface ButtonProps {<br>  onClick: (event: React.MouseEvent&lt;HTMLButtonElement&gt;) => void;<br>  label: string;<br>}<br><br>function Button({ onClick, label }: ButtonProps) {<br>  return &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;;<br>}</code><br><br>4. <strong>Simplified function signatures</strong> for props (when event object isn't needed):<br><code>interface InputProps {<br>  value: string;<br>  // Simplified signature that doesn't expose the event<br>  onChange: (value: string) => void;<br>}<br><br>function Input({ value, onChange }: InputProps) {<br>  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {<br>    onChange(e.target.value);<br>  };<br>  <br>  return &lt;input value={value} onChange={handleChange} /&gt;;<br>}</code><br><br>5. <strong>Generic event handlers</strong> for reusable components:<br><code>function useEventCallback&lt;T extends HTMLElement&gt;() {<br>  const handleEvent = useCallback(<br>    (event: React.SyntheticEvent&lt;T&gt;, callback?: (event: React.SyntheticEvent&lt;T&gt;) => void) => {<br>      if (callback) {<br>        callback(event);<br>      }<br>    },<br>    []<br>  );<br>  <br>  return handleEvent;<br>}</code><br><br>6. <strong>Inline event handlers</strong>:<br><code>&lt;button <br>  onClick={(e: React.MouseEvent&lt;HTMLButtonElement&gt;) => {<br>    console.log('Button clicked', e.currentTarget.name);<br>  }}<br>&gt;<br>  Click me<br>&lt;/button&gt;</code><br><br>7. <strong>Handling native events</strong> (e.g., with useEffect):<br><code>useEffect(() => {<br>  const handleResize = (event: UIEvent) => {<br>    console.log('Window resized', window.innerWidth);<br>  };<br>  <br>  window.addEventListener('resize', handleResize);<br>  return () => window.removeEventListener('resize', handleResize);<br>}, []);</code><br><br>The key is to use the appropriate event type for each interaction, and to consider whether to expose the full event object in your component APIs or abstract it away with simplified function signatures.",
      },
      {
        text: 'How do you type children in React components?',
        answer:
          'Typing children in React components can be done in several ways depending on what constraints you want to enforce:<br><br>1. <strong>Using React.ReactNode</strong> (most common and flexible):<br><code>interface ContainerProps {<br>  children: React.ReactNode; // Accepts any valid JSX content<br>}<br><br>function Container({ children }: ContainerProps) {<br>  return &lt;div className="container"&gt;{children}&lt;/div&gt;;<br>}</code><br><br>2. <strong>Using React.ReactElement</strong> (more restrictive, elements only):<br><code>interface TabProps {<br>  children: React.ReactElement; // Only accepts a single React element, not text or arrays<br>}<br><br>function Tab({ children }: TabProps) {<br>  return &lt;div className="tab"&gt;{children}&lt;/div&gt;;<br>}</code><br><br>3. <strong>For multiple elements of a specific type</strong>:<br><code>interface TabsProps {<br>  children: React.ReactElement[] | React.ReactElement;<br>}<br><br>function Tabs({ children }: TabsProps) {<br>  return &lt;div className="tabs"&gt;{children}&lt;/div&gt;;<br>}</code><br><br>4. <strong>For a specific component type</strong> (using JSX.Element with type checking):<br><code>import { isValidElement } from \'react\';<br><br>interface TabsProps {<br>  children: React.ReactNode;<br>}<br><br>function Tabs({ children }: TabsProps) {<br>  // Enforce Tab children at runtime<br>  const validChildren = React.Children.map(children, child => {<br>    if (isValidElement(child) && child.type === Tab) {<br>      return child;<br>    }<br>    throw new Error(\'Tabs children must be Tab components\');<br>  });<br>  <br>  return &lt;div className="tabs"&gt;{validChildren}&lt;/div&gt;;<br>}</code><br><br>5. <strong>When children is a function</strong> (render props pattern):<br><code>interface RenderProps {<br>  count: number;<br>  increment: () => void;<br>}<br><br>interface CounterProps {<br>  children: (props: RenderProps) => React.ReactNode;<br>  initial?: number;<br>}<br><br>function Counter({ children, initial = 0 }: CounterProps) {<br>  const [count, setCount] = useState(initial);<br>  const increment = () => setCount(c => c + 1);<br>  <br>  return &lt;&gt;{children({ count, increment })}&lt;/&gt;;<br>}</code><br><br>6. <strong>String-only children</strong>:<br><code>interface HeadingProps {<br>  children: string;<br>  level?: 1 | 2 | 3 | 4 | 5 | 6;<br>}<br><br>function Heading({ children, level = 1 }: HeadingProps) {<br>  const Tag = `h${level}` as keyof JSX.IntrinsicElements;<br>  return &lt;Tag&gt;{children}&lt;/Tag&gt;;<br>}</code><br><br>7. <strong>Optional children</strong>:<br><code>interface CardProps {<br>  title: string;<br>  children?: React.ReactNode;<br>}<br><br>function Card({ title, children }: CardProps) {<br>  return (<br>    &lt;div className="card"&gt;<br>      &lt;h2&gt;{title}&lt;/h2&gt;<br>      {children && &lt;div className="card-body"&gt;{children}&lt;/div&gt;}<br>    &lt;/div&gt;<br>  );<br>}</code><br><br>8. <strong>Using React.FC</strong> (though less recommended now):<br><code>const Container: React.FC = ({ children }) => {<br>  return &lt;div&gt;{children}&lt;/div&gt;;<br>};</code><br><br>For most cases, <code>React.ReactNode</code> provides the right balance of flexibility and type safety.',
      },
      {
        text: 'How would you create a polymorphic component in TypeScript?',
        answer:
          "A polymorphic component can render as different HTML elements while maintaining proper type safety. Creating one in TypeScript is a bit advanced but very useful:<br><br>1. <strong>Basic polymorphic component approach</strong>:<br><code>import React, { ElementType, ComponentProps, ReactNode } from 'react';<br><br>type BoxProps&lt;E extends ElementType = 'div'&gt; = {<br>  as?: E;<br>  children: ReactNode;<br>} & Omit&lt;ComponentProps&lt;E&gt;, 'as' | 'children'&gt;;<br><br>function Box&lt;E extends ElementType = 'div'&gt;({<br>  as,<br>  children,<br>  ...rest<br>}: BoxProps&lt;E&gt;) {<br>  const Component = as || 'div';<br>  return &lt;Component {...rest}&gt;{children}&lt;/Component&gt;;<br>}</code><br><br>2. <strong>Advanced polymorphic component with ref support</strong>:<br><code>import React, { ElementType, ComponentPropsWithRef, forwardRef } from 'react';<br><br>type AsProp&lt;C extends ElementType&gt; = {<br>  as?: C;<br>};<br><br>type PropsToOmit&lt;C extends ElementType, P&gt; = keyof (AsProp&lt;C&gt; & P);<br><br>type PolymorphicComponentProp&lt;<br>  C extends ElementType,<br>  Props = {}<br>&gt; = PropsToOmit&lt;C, Props&gt; extends infer O<br>  ? O extends keyof ComponentPropsWithRef&lt;C&gt;<br>    ? Omit&lt;ComponentPropsWithRef&lt;C&gt;, O&gt; & Props & AsProp&lt;C&gt;<br>    : never<br>  : never;<br><br>type PolymorphicRef&lt;C extends ElementType&gt; = ComponentPropsWithRef&lt;C&gt;['ref'];<br><br>type PolymorphicComponentPropWithRef&lt;<br>  C extends ElementType,<br>  Props = {}<br>&gt; = PolymorphicComponentProp&lt;C, Props&gt; & { ref?: PolymorphicRef&lt;C&gt; };<br><br>// For the actual component implementation<br>type TextProps&lt;C extends ElementType&gt; = PolymorphicComponentPropWithRef&lt;<br>  C,<br>  { variant?: 'heading' | 'body' | 'caption' }<br>&gt;;<br><br>type TextComponent = &lt;C extends ElementType = 'span'&gt;(<br>  props: TextProps&lt;C&gt;<br>) => React.ReactElement | null;<br><br>// The actual component implementation<br>const Text: TextComponent = forwardRef(<br>  &lt;C extends ElementType = 'span'&gt;(<br>    { as, variant = 'body', children, ...rest }: TextProps&lt;C&gt;,<br>    ref?: PolymorphicRef&lt;C&gt;<br>  ) => {<br>    const Component = as || 'span';<br>    <br>    return (<br>      &lt;Component<br>        ref={ref}<br>        className={`text-${variant}`}<br>        {...rest}<br>      &gt;<br>        {children}<br>      &lt;/Component&gt;<br>    );<br>  }<br>);</code><br><br>3. <strong>Usage examples</strong>:<br><code>// Basic usage<br>&lt;Box&gt;I'm a div&lt;/Box&gt;<br><br>// As a different element<br>&lt;Box as=\"span\"&gt;I'm a span&lt;/Box&gt;<br><br>// With element-specific props<br>&lt;Box as=\"a\" href=\"https://example.com\"&gt;I'm a link&lt;/Box&gt;<br><br>// With variant<br>&lt;Text variant=\"heading\" as=\"h1\"&gt;Heading&lt;/Text&gt;<br><br>// With ref<br>const buttonRef = useRef&lt;HTMLButtonElement&gt;(null);<br>&lt;Text as=\"button\" ref={buttonRef}&gt;Click me&lt;/Text&gt;</code><br><br>Key benefits of polymorphic components:<br>- Allow flexibility in rendered element<br>- Maintain type safety for element-specific props<br>- Enable forwarding refs to the correct element type<br>- Provide a consistent way to customize base components<br><br>This pattern is commonly used in component libraries like Chakra UI, Material UI, and others to provide highly flexible base components.",
      },
      {
        text: 'How do you type context and context providers in React with TypeScript?',
        answer:
          "Type-safe context in React with TypeScript involves several steps:<br><br>1. <strong>Define the context type</strong>:<br><code>interface ThemeContextType {<br>  theme: 'light' | 'dark';<br>  toggleTheme: () => void;<br>}</code><br><br>2. <strong>Create context with a default value</strong>:<br><code>// Default value matching the type (Option 1)<br>const ThemeContext = React.createContext&lt;ThemeContextType&gt;({<br>  theme: 'light',<br>  toggleTheme: () => {}<br>});<br><br>// OR using undefined with a type assertion (Option 2)<br>const ThemeContext = React.createContext&lt;ThemeContextType | undefined&gt;(undefined);</code><br><br>3. <strong>Create the provider component</strong>:<br><code>interface ThemeProviderProps {<br>  children: React.ReactNode;<br>  initialTheme?: 'light' | 'dark';<br>}<br><br>export const ThemeProvider: React.FC&lt;ThemeProviderProps&gt; = ({ <br>  children, <br>  initialTheme = 'light' <br>}) => {<br>  const [theme, setTheme] = useState&lt;'light' | 'dark'&gt;(initialTheme);<br>  <br>  const toggleTheme = useCallback(() => {<br>    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));<br>  }, []);<br>  <br>  // Memoize the context value to prevent unnecessary re-renders<br>  const value = useMemo(<br>    () => ({<br>      theme,<br>      toggleTheme<br>    }),<br>    [theme, toggleTheme]<br>  );<br>  <br>  return (<br>    &lt;ThemeContext.Provider value={value}&gt;<br>      {children}<br>    &lt;/ThemeContext.Provider&gt;<br>  );<br>};</code><br><br>4. <strong>Create a custom hook for consuming the context</strong>:<br><code>export const useTheme = () => {<br>  const context = useContext(ThemeContext);<br>  <br>  // Only necessary if you used Option 2 (undefined default)<br>  if (context === undefined) {<br>    throw new Error('useTheme must be used within a ThemeProvider');<br>  }<br>  <br>  return context;<br>};</code><br><br>5. <strong>Usage example</strong>:<br><code>function ThemedButton() {<br>  const { theme, toggleTheme } = useTheme();<br>  <br>  return (<br>    &lt;button<br>      onClick={toggleTheme}<br>      style={{<br>        backgroundColor: theme === 'light' ? '#fff' : '#333',<br>        color: theme === 'light' ? '#333' : '#fff'<br>      }}<br>    &gt;<br>      Toggle Theme<br>    &lt;/button&gt;<br>  );<br>}</code><br><br>6. <strong>Multiple contexts composition</strong>:<br><code>// Define an AppProviders component that composes multiple providers<br>export const AppProviders: React.FC&lt;{ children: React.ReactNode }&gt; = ({ children }) => {<br>  return (<br>    &lt;AuthProvider&gt;<br>      &lt;ThemeProvider&gt;<br>        &lt;NotificationProvider&gt;<br>          {children}<br>        &lt;/NotificationProvider&gt;<br>      &lt;/ThemeProvider&gt;<br>    &lt;/AuthProvider&gt;<br>  );<br>};</code><br><br>7. <strong>Generic context for flexible data</strong>:<br><code>interface DataContextType&lt;T&gt; {<br>  data: T | null;<br>  setData: (data: T) => void;<br>}<br><br>function createDataContext&lt;T&gt;() {<br>  const DataContext = React.createContext&lt;DataContextType&lt;T&gt; | undefined&gt;(undefined);<br>  <br>  const DataProvider: React.FC&lt;{ children: React.ReactNode }&gt; = ({ children }) => {<br>    const [data, setData] = useState&lt;T | null&gt;(null);<br>    <br>    return (<br>      &lt;DataContext.Provider value={{ data, setData }}&gt;<br>        {children}<br>      &lt;/DataContext.Provider&gt;<br>    );<br>  };<br>  <br>  const useData = () => {<br>    const context = useContext(DataContext);<br>    <br>    if (context === undefined) {<br>      throw new Error('useData must be used within a DataProvider');<br>    }<br>    <br>    return context;<br>  };<br>  <br>  return { DataProvider, useData };<br>}</code><br><br>The keys to well-typed context are:<br>- Clear interface definitions for the context value<br>- Proper typing of the provider component<br>- Using custom hooks to enforce usage within providers<br>- Memoizing context values to prevent unnecessary re-renders",
      },
    ],
  },
  {
    id: 'typescript-hooks-state',
    title: 'TypeScript with Hooks and State Management',
    questions: [
      {
        text: 'How do you type the useState hook in React with TypeScript?',
        answer:
          "Typing the <code>useState</code> hook in React with TypeScript can be done in several ways:<br><br>1. <strong>Basic usage with type inference</strong>:<br><code>// TypeScript infers string type automatically<br>const [name, setName] = useState('John');<br><br>// TypeScript infers number type automatically<br>const [count, setCount] = useState(0);<br><br>// TypeScript infers boolean type automatically<br>const [isActive, setIsActive] = useState(false);</code><br><br>2. <strong>Explicit type annotation</strong>:<br><code>// Explicitly define the state type<br>const [name, setName] = useState&lt;string&gt;('');<br><br>// For nullable values<br>const [user, setUser] = useState&lt;User | null&gt;(null);</code><br><br>3. <strong>Complex types</strong>:<br><code>interface User {<br>  id: number;<br>  name: string;<br>  email: string;<br>}<br><br>// Object state<br>const [user, setUser] = useState&lt;User&gt;({<br>  id: 1,<br>  name: 'John',<br>  email: 'john@example.com'<br>});<br><br>// Array state<br>const [items, setItems] = useState&lt;string[]&gt;([]);<br><br>// State that might be undefined<br>const [data, setData] = useState&lt;ApiData | undefined&gt;(undefined);</code><br><br>4. <strong>Union types</strong>:<br><code>// State can be one of several types<br>type Status = 'idle' | 'loading' | 'success' | 'error';<br>const [status, setStatus] = useState&lt;Status&gt;('idle');<br><br>// State with different possible types<br>const [id, setId] = useState&lt;string | number&gt;('abc123');</code><br><br>5. <strong>Type for functions that update state</strong>:<br><code>// Inferred typing (preferred approach)<br>const [count, setCount] = useState(0);<br>// setCount is typed as Dispatch&lt;SetStateAction&lt;number&gt;&gt;<br><br>// Using updater function<br>setCount(prevCount => prevCount + 1);</code><br><br>6. <strong>With discriminated unions for complex states</strong>:<br><code>type RequestState&lt;T&gt; =<br>  | { status: 'idle' }<br>  | { status: 'loading' }<br>  | { status: 'error'; error: Error }<br>  | { status: 'success'; data: T };<br><br>const [state, setState] = useState&lt;RequestState&lt;User&gt;&gt;({ status: 'idle' });<br><br>// Properly typed state updates<br>setState({ status: 'loading' });<br>setState({ status: 'success', data: userData });<br>setState({ status: 'error', error: new Error('Failed to fetch') });</code><br><br>7. <strong>With type inference using a factory function</strong>:<br><code>function createUser() {<br>  return { id: 0, name: '', email: '' };<br>}<br><br>// TypeScript infers the return type of createUser<br>const [user, setUser] = useState(createUser());</code><br><br>8. <strong>Lazy initialization with proper typing</strong>:<br><code>const [user, setUser] = useState(() => {<br>  const savedUser = localStorage.getItem('user');<br>  if (savedUser) {<br>    return JSON.parse(savedUser) as User;<br>  }<br>  return null as User | null;<br>});</code><br><br>Best practices:<br>- Let TypeScript infer the type when initializing with a value<br>- Provide explicit types for nullable or union types<br>- Use discriminated unions for complex state with different shapes<br>- Avoid using <code>any</code> as it defeats the purpose of type checking",
      },
      {
        text: 'How do you type useReducer in TypeScript?',
        answer:
          "Typing <code>useReducer</code> in TypeScript involves properly typing the state, actions, and reducer function:<br><br>1. <strong>Define state and action types</strong>:<br><code>// State type<br>interface CounterState {<br>  count: number;<br>  step?: number;<br>}<br><br>// Action types with discriminated union<br>type CounterAction =<br>  | { type: 'INCREMENT' }<br>  | { type: 'DECREMENT' }<br>  | { type: 'RESET' }<br>  | { type: 'SET_COUNT'; payload: number }<br>  | { type: 'SET_STEP'; payload: number };</code><br><br>2. <strong>Implement the typed reducer</strong>:<br><code>function counterReducer(state: CounterState, action: CounterAction): CounterState {<br>  switch (action.type) {<br>    case 'INCREMENT':<br>      return { ...state, count: state.count + (state.step || 1) };<br>    case 'DECREMENT':<br>      return { ...state, count: state.count - (state.step || 1) };<br>    case 'RESET':<br>      return { count: 0 };<br>    case 'SET_COUNT':<br>      return { ...state, count: action.payload };<br>    case 'SET_STEP':<br>      return { ...state, step: action.payload };<br>    default:<br>      // TypeScript exhaustiveness checking<br>      const _exhaustiveCheck: never = action;<br>      return state;<br>  }<br>}</code><br><br>3. <strong>Use the typed reducer with useReducer</strong>:<br><code>const initialState: CounterState = { count: 0, step: 1 };<br><br>function Counter() {<br>  const [state, dispatch] = useReducer(counterReducer, initialState);<br>  <br>  return (<br>    &lt;div&gt;<br>      Count: {state.count}<br>      Step: {state.step}<br>      <br>      &lt;button onClick={() => dispatch({ type: 'INCREMENT' })}&gt;+&lt;/button&gt;<br>      &lt;button onClick={() => dispatch({ type: 'DECREMENT' })}&gt;-&lt;/button&gt;<br>      &lt;button onClick={() => dispatch({ type: 'RESET' })}&gt;Reset&lt;/button&gt;<br>      &lt;button onClick={() => dispatch({ type: 'SET_COUNT', payload: 10 })}&gt;<br>        Set to 10<br>      &lt;/button&gt;<br>      &lt;button onClick={() => dispatch({ type: 'SET_STEP', payload: 5 })}&gt;<br>        Set Step to 5<br>      &lt;/button&gt;<br>    &lt;/div&gt;<br>  );<br>}</code><br><br>4. <strong>Generic reducer for reusable patterns</strong>:<br><code>interface State&lt;T&gt; {<br>  data: T | null;<br>  loading: boolean;<br>  error: Error | null;<br>}<br><br>type Action&lt;T&gt; =<br>  | { type: 'LOADING' }<br>  | { type: 'SUCCESS'; payload: T }<br>  | { type: 'ERROR'; error: Error };<br><br>function reducer&lt;T&gt;(state: State&lt;T&gt;, action: Action&lt;T&gt;): State&lt;T&gt; {<br>  switch (action.type) {<br>    case 'LOADING':<br>      return { ...state, loading: true, error: null };<br>    case 'SUCCESS':<br>      return { data: action.payload, loading: false, error: null };<br>    case 'ERROR':<br>      return { ...state, loading: false, error: action.error };<br>    default:<br>      return state;<br>  }<br>}</code><br><br>5. <strong>Using the generic reducer with a specific type</strong>:<br><code>interface User {<br>  id: number;<br>  name: string;<br>}<br><br>function UserProfile() {<br>  const initialState: State&lt;User&gt; = {<br>    data: null,<br>    loading: false,<br>    error: null<br>  };<br>  <br>  const [state, dispatch] = useReducer(reducer&lt;User&gt;, initialState);<br>  <br>  const fetchUser = async (id: number) => {<br>    dispatch({ type: 'LOADING' });<br>    <br>    try {<br>      const response = await fetch(`/api/users/${id}`);<br>      const user = await response.json();<br>      dispatch({ type: 'SUCCESS', payload: user });<br>    } catch (error) {<br>      dispatch({ type: 'ERROR', error: error as Error });<br>    }<br>  };<br>  <br>  // Component implementation<br>}</code><br><br>6. <strong>Adding action creators for better type safety</strong>:<br><code>// Typed action creators<br>const incrementAction = () => ({ type: 'INCREMENT' as const });<br>const decrementAction = () => ({ type: 'DECREMENT' as const });<br>const resetAction = () => ({ type: 'RESET' as const });<br>const setCountAction = (count: number) => ({ <br>  type: 'SET_COUNT' as const, <br>  payload: count <br>});<br>const setStepAction = (step: number) => ({ <br>  type: 'SET_STEP' as const, <br>  payload: step <br>});<br><br>// Infer action types from action creators<br>type CounterAction = ReturnType&lt;typeof incrementAction&gt; | <br>  ReturnType&lt;typeof decrementAction&gt; | <br>  ReturnType&lt;typeof resetAction&gt; | <br>  ReturnType&lt;typeof setCountAction&gt; | <br>  ReturnType&lt;typeof setStepAction&gt;;</code><br><br>Key points:<br>- Use discriminated unions for type-safe actions<br>- Add exhaustiveness checking to catch missing action handlers<br>- Consider using action creators for better type inference<br>- Use generics for reusable reducer patterns<br>- TypeScript will automatically infer the dispatch type from your reducer",
      },
      {
        text: 'How do you create and type custom hooks in TypeScript?',
        answer:
          "Creating and typing custom hooks in TypeScript combines React hook patterns with type safety:<br><br>1. <strong>Basic custom hook</strong>:<br><code>function useToggle(initialValue: boolean = false) {<br>  const [value, setValue] = useState(initialValue);<br>  <br>  const toggle = useCallback(() => {<br>    setValue(v => !v);<br>  }, []);<br>  <br>  return [value, toggle] as const; // Use const assertion for tuple return type<br>}</code><br><br>2. <strong>Custom hook with multiple return values</strong>:<br><code>function useCounter(initialValue: number = 0, step: number = 1) {<br>  const [count, setCount] = useState(initialValue);<br>  <br>  const increment = useCallback(() => {<br>    setCount(c => c + step);<br>  }, [step]);<br>  <br>  const decrement = useCallback(() => {<br>    setCount(c => c - step);<br>  }, [step]);<br>  <br>  const reset = useCallback(() => {<br>    setCount(initialValue);<br>  }, [initialValue]);<br>  <br>  // Return object with named values<br>  return {<br>    count,<br>    increment,<br>    decrement,<br>    reset<br>  };<br>}</code><br><br>3. <strong>Custom hook with explicit return type</strong>:<br><code>interface UseCounterReturn {<br>  count: number;<br>  increment: () => void;<br>  decrement: () => void;<br>  reset: () => void;<br>  setCount: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;;<br>}<br><br>function useCounter(initialValue: number = 0): UseCounterReturn {<br>  const [count, setCount] = useState(initialValue);<br>  <br>  const increment = useCallback(() => {<br>    setCount(c => c + 1);<br>  }, []);<br>  <br>  const decrement = useCallback(() => {<br>    setCount(c => c - 1);<br>  }, []);<br>  <br>  const reset = useCallback(() => {<br>    setCount(initialValue);<br>  }, [initialValue]);<br>  <br>  return {<br>    count,<br>    increment,<br>    decrement,<br>    reset,<br>    setCount<br>  };<br>}</code><br><br>4. <strong>Generic custom hook</strong>:<br><code>function useLocalStorage&lt;T&gt;(key: string, initialValue: T) {<br>  // State to store our value<br>  const [storedValue, setStoredValue] = useState&lt;T&gt;(() => {<br>    try {<br>      // Get from local storage by key<br>      const item = window.localStorage.getItem(key);<br>      // Parse stored json or if none return initialValue<br>      return item ? JSON.parse(item) : initialValue;<br>    } catch (error) {<br>      console.error(error);<br>      return initialValue;<br>    }<br>  });<br>  <br>  // Function to save to localStorage and update state<br>  const setValue = useCallback((value: T | ((val: T) => T)) => {<br>    try {<br>      // Allow value to be a function<br>      const valueToStore =<br>        value instanceof Function ? value(storedValue) : value;<br>      <br>      // Save state<br>      setStoredValue(valueToStore);<br>      <br>      // Save to localStorage<br>      window.localStorage.setItem(key, JSON.stringify(valueToStore));<br>    } catch (error) {<br>      console.error(error);<br>    }<br>  }, [key, storedValue]);<br>  <br>  return [storedValue, setValue] as const;<br>}</code><br><br>5. <strong>Custom hook with conditional types</strong>:<br><code>type UseAsyncReturn&lt;T&gt; = {<br>  data: T | null;<br>  loading: boolean;<br>  error: Error | null;<br>  execute: () => Promise&lt;T&gt;;<br>  reset: () => void;<br>};<br><br>function useAsync&lt;T&gt;(asyncFunction: () => Promise&lt;T&gt;, immediate = true): UseAsyncReturn&lt;T&gt; {<br>  const [status, setStatus] = useState&lt;'idle' | 'pending' | 'success' | 'error'&gt;('idle');<br>  const [data, setData] = useState&lt;T | null&gt;(null);<br>  const [error, setError] = useState&lt;Error | null&gt;(null);<br>  <br>  // The execute function wraps asyncFunction and<br>  // handles setting state<br>  const execute = useCallback(async () => {<br>    setStatus('pending');<br>    setData(null);<br>    setError(null);<br>    <br>    try {<br>      const response = await asyncFunction();<br>      setData(response);<br>      setStatus('success');<br>      return response;<br>    } catch (err) {<br>      setError(err instanceof Error ? err : new Error(String(err)));<br>      setStatus('error');<br>      throw err;<br>    }<br>  }, [asyncFunction]);<br>  <br>  // Reset to initial state<br>  const reset = useCallback(() => {<br>    setStatus('idle');<br>    setData(null);<br>    setError(null);<br>  }, []);<br>  <br>  // Call execute if immediate is true<br>  useEffect(() => {<br>    if (immediate) {<br>      execute();<br>    }<br>  }, [execute, immediate]);<br>  <br>  return {<br>    data,<br>    loading: status === 'pending',<br>    error,<br>    execute,<br>    reset<br>  };<br>}</code><br><br>6. <strong>Hook that consumes other hooks</strong>:<br><code>interface UseUserResult {<br>  user: User | null;<br>  loading: boolean;<br>  error: Error | null;<br>  refetch: () => Promise&lt;User&gt;;<br>  logout: () => void;<br>}<br><br>function useUser(userId: string): UseUserResult {<br>  // Reuse the useAsync hook<br>  const {<br>    data: user,<br>    loading,<br>    error,<br>    execute: refetch<br>  } = useAsync&lt;User&gt;(() => fetchUser(userId), true);<br>  <br>  // Add additional functionality<br>  const logout = useCallback(() => {<br>    // Logout logic<br>  }, []);<br>  <br>  return { user, loading, error, refetch, logout };<br>}</code><br><br>7. <strong>Using React.Context with custom hooks</strong>:<br><code>function useThemeContext(): ThemeContextType {<br>  const context = useContext(ThemeContext);<br>  <br>  if (context === undefined) {<br>    throw new Error('useThemeContext must be used within a ThemeProvider');<br>  }<br>  <br>  return context;<br>}</code><br><br>Best practices:<br>- Use const assertions (<code>as const</code>) for tuple returns to preserve types<br>- Create interfaces for return types of complex hooks<br>- Use generics for flexible, reusable hooks<br>- Include proper error handling and loading states<br>- Consider memoization with useCallback/useMemo for functions and values<br>- Use descriptive names that follow the use-prefix convention",
      },
      {
        text: 'How do you type Redux with TypeScript?',
        answer:
          "Typing Redux with TypeScript provides type safety for your state management. Here's a comprehensive approach:<br><br>1. <strong>Define the state shape</strong>:<br><code>// Root state type<br>interface RootState {<br>  counter: CounterState;<br>  users: UsersState;<br>  // other slices...<br>}<br><br>// Counter slice state<br>interface CounterState {<br>  value: number;<br>  status: 'idle' | 'loading' | 'failed';<br>}<br><br>// Users slice state<br>interface UsersState {<br>  list: User[];<br>  selectedId: number | null;<br>  loading: boolean;<br>}</code><br><br>2. <strong>Type action types and action creators</strong>:<br><code>// Using string literals and enums<br>enum CounterActionTypes {<br>  INCREMENT = 'counter/increment',<br>  DECREMENT = 'counter/decrement',<br>  INCREMENT_BY_AMOUNT = 'counter/incrementByAmount'<br>}<br><br>// Action interfaces<br>interface IncrementAction {<br>  type: CounterActionTypes.INCREMENT;<br>}<br><br>interface DecrementAction {<br>  type: CounterActionTypes.DECREMENT;<br>}<br><br>interface IncrementByAmountAction {<br>  type: CounterActionTypes.INCREMENT_BY_AMOUNT;<br>  payload: number;<br>}<br><br>// Union of all actions<br>type CounterAction = <br>  | IncrementAction <br>  | DecrementAction <br>  | IncrementByAmountAction;<br><br>// Type-safe action creators<br>function increment(): IncrementAction {<br>  return { type: CounterActionTypes.INCREMENT };<br>}<br><br>function decrement(): DecrementAction {<br>  return { type: CounterActionTypes.DECREMENT };<br>}<br><br>function incrementByAmount(amount: number): IncrementByAmountAction {<br>  return { <br>    type: CounterActionTypes.INCREMENT_BY_AMOUNT, <br>    payload: amount <br>  };<br>}</code><br><br>3. <strong>Type reducers</strong>:<br><code>// Initial state<br>const initialState: CounterState = {<br>  value: 0,<br>  status: 'idle'<br>};<br><br>// Type-safe reducer<br>function counterReducer(state = initialState, action: CounterAction): CounterState {<br>  switch (action.type) {<br>    case CounterActionTypes.INCREMENT:<br>      return { ...state, value: state.value + 1 };<br>    case CounterActionTypes.DECREMENT:<br>      return { ...state, value: state.value - 1 };<br>    case CounterActionTypes.INCREMENT_BY_AMOUNT:<br>      return { ...state, value: state.value + action.payload };<br>    default:<br>      return state;<br>  }<br>}</code><br><br>4. <strong>Type selectors</strong>:<br><code>// Basic selector<br>const selectCount = (state: RootState) => state.counter.value;<br><br>// Complex selector<br>const selectDoubledCount = (state: RootState) => state.counter.value * 2;</code><br><br>5. <strong>Type Thunk actions</strong>:<br><code>import { ThunkAction } from 'redux-thunk';<br>import { Action } from 'redux';<br><br>// Define the return type of thunks<br>type AppThunk&lt;ReturnType = void&gt; = ThunkAction&lt;<br>  ReturnType,<br>  RootState,<br>  unknown,<br>  Action&lt;string&gt;<br>&gt;;<br><br>// Typed thunk action creator<br>export const incrementAsync = (amount: number): AppThunk => async dispatch => {<br>  dispatch({ type: 'counter/incrementPending' });<br>  <br>  try {<br>    // Simulate API call<br>    await new Promise(resolve => setTimeout(resolve, 1000));<br>    dispatch(incrementByAmount(amount));<br>  } catch (error) {<br>    dispatch({ type: 'counter/incrementFailed', error });<br>  }<br>};</code><br><br>6. <strong>Redux hooks with TypeScript</strong>:<br><code>import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';<br><br>// Define types for hooks<br>export type AppDispatch = typeof store.dispatch;<br>export const useAppDispatch = () => useDispatch&lt;AppDispatch&gt;();<br>export const useAppSelector: TypedUseSelectorHook&lt;RootState&gt; = useSelector;</code><br><br>7. <strong>Using typed hooks in components</strong>:<br><code>function Counter() {<br>  // Use the typed hooks<br>  const count = useAppSelector(state => state.counter.value);<br>  const dispatch = useAppDispatch();<br>  <br>  return (<br>    &lt;div&gt;<br>      &lt;div&gt;Count: {count}&lt;/div&gt;<br>      &lt;button onClick={() => dispatch(increment())}&gt;Increment&lt;/button&gt;<br>      &lt;button onClick={() => dispatch(decrement())}&gt;Decrement&lt;/button&gt;<br>      &lt;button onClick={() => dispatch(incrementByAmount(5))}&gt;+5&lt;/button&gt;<br>      &lt;button onClick={() => dispatch(incrementAsync(10))}&gt;+10 Async&lt;/button&gt;<br>    &lt;/div&gt;<br>  );<br>}</code><br><br>8. <strong>Modern approach with Redux Toolkit</strong>:<br><code>import { createSlice, PayloadAction, configureStore } from '@reduxjs/toolkit';<br><br>// Create a slice<br>const counterSlice = createSlice({<br>  name: 'counter',<br>  initialState: { value: 0, status: 'idle' } as CounterState,<br>  reducers: {<br>    // Action creators are generated automatically<br>    increment: state => {<br>      state.value += 1;<br>    },<br>    decrement: state => {<br>      state.value -= 1;<br>    },<br>    // Use PayloadAction type for actions with payload<br>    incrementByAmount: (state, action: PayloadAction&lt;number&gt;) => {<br>      state.value += action.payload;<br>    }<br>  }<br>});<br><br>// Extract action creators and reducer<br>export const { increment, decrement, incrementByAmount } = counterSlice.actions;<br>export default counterSlice.reducer;<br><br>// Configure store with typed reducers<br>export const store = configureStore({<br>  reducer: {<br>    counter: counterSlice.reducer<br>  }<br>});<br><br>// Infer RootState and AppDispatch types from the store<br>export type RootState = ReturnType&lt;typeof store.getState&gt;;<br>export type AppDispatch = typeof store.dispatch;</code><br><br>Best practices:<br>- Use Redux Toolkit for simpler, more type-safe Redux code<br>- Create typed versions of useSelector and useDispatch<br>- Define action types as string literals or enums<br>- Use discriminated unions for actions<br>- Define the shape of your state with interfaces<br>- Use PayloadAction type for actions with payload",
      },
      {
        text: 'How do you handle asynchronous operations in TypeScript with React?',
        answer:
          "Handling asynchronous operations in TypeScript with React requires proper typing of promises, state, and error handling:<br><br>1. <strong>Basic Promise handling</strong>:<br><code>async function fetchData(): Promise&lt;User&gt; {<br>  const response = await fetch('/api/user');<br>  <br>  if (!response.ok) {<br>    throw new Error(`HTTP error! Status: ${response.status}`);<br>  }<br>  <br>  return response.json() as Promise&lt;User&gt;;<br>}</code><br><br>2. <strong>Using async/await in event handlers</strong>:<br><code>const handleSubmit = async (event: React.FormEvent) => {<br>  event.preventDefault();<br>  <br>  try {<br>    setLoading(true);<br>    const result = await submitForm(formData);<br>    setSuccess(true);<br>    setResponseData(result);<br>  } catch (error) {<br>    setError(error instanceof Error ? error.message : String(error));<br>  } finally {<br>    setLoading(false);<br>  }<br>};</code><br><br>3. <strong>Typed async state with useState</strong>:<br><code>interface User {<br>  id: number;<br>  name: string;<br>  email: string;<br>}<br><br>function UserProfile({ userId }: { userId: number }) {<br>  const [user, setUser] = useState&lt;User | null&gt;(null);<br>  const [loading, setLoading] = useState(false);<br>  const [error, setError] = useState&lt;string | null&gt;(null);<br>  <br>  useEffect(() => {<br>    const fetchUser = async () => {<br>      try {<br>        setLoading(true);<br>        setError(null);<br>        <br>        const data = await fetchUserById(userId);<br>        setUser(data);<br>      } catch (err) {<br>        setError(err instanceof Error ? err.message : 'An error occurred');<br>        setUser(null);<br>      } finally {<br>        setLoading(false);<br>      }<br>    };<br>    <br>    fetchUser();<br>  }, [userId]);<br>  <br>  // Rest of component<br>}</code><br><br>4. <strong>Using discriminated union for request state</strong>:<br><code>type RequestState&lt;T&gt; =<br>  | { status: 'idle' }<br>  | { status: 'loading' }<br>  | { status: 'success'; data: T }<br>  | { status: 'error'; error: Error };<br><br>function UserProfile({ userId }: { userId: number }) {<br>  const [state, setState] = useState&lt;RequestState&lt;User&gt;&gt;({ status: 'idle' });<br>  <br>  useEffect(() => {<br>    const fetchUser = async () => {<br>      setState({ status: 'loading' });<br>      try {<br>        const data = await fetchUserById(userId);<br>        setState({ status: 'success', data });<br>      } catch (error) {<br>        setState({ <br>          status: 'error', <br>          error: error instanceof Error ? error : new Error(String(error)) <br>        });<br>      }<br>    };<br>    <br>    fetchUser();<br>  }, [userId]);<br>  <br>  // Handle different states with type narrowing<br>  switch (state.status) {<br>    case 'loading':<br>      return &lt;div&gt;Loading...&lt;/div&gt;;<br>    case 'error':<br>      return &lt;div&gt;Error: {state.error.message}&lt;/div&gt;;<br>    case 'success':<br>      return (<br>        &lt;div&gt;<br>          &lt;h1&gt;{state.data.name}&lt;/h1&gt;<br>          &lt;p&gt;{state.data.email}&lt;/p&gt;<br>        &lt;/div&gt;<br>      );<br>    case 'idle':<br>    default:<br>      return &lt;div&gt;Ready to load user&lt;/div&gt;;<br>  }<br>}</code><br><br>5. <strong>Custom hook for data fetching</strong>:<br><code>function useFetch&lt;T&gt;(url: string) {<br>  const [state, setState] = useState&lt;RequestState&lt;T&gt;&gt;({ status: 'idle' });<br>  <br>  useEffect(() => {<br>    const abortController = new AbortController();<br>    const signal = abortController.signal;<br>    <br>    const fetchData = async () => {<br>      setState({ status: 'loading' });<br>      <br>      try {<br>        const response = await fetch(url, { signal });<br>        <br>        if (!response.ok) {<br>          throw new Error(`HTTP error! Status: ${response.status}`);<br>        }<br>        <br>        const data = await response.json();<br>        if (!signal.aborted) {<br>          setState({ status: 'success', data });<br>        }<br>      } catch (error) {<br>        if (!signal.aborted) {<br>          setState({ <br>            status: 'error', <br>            error: error instanceof Error ? error : new Error(String(error)) <br>          });<br>        }<br>      }<br>    };<br>    <br>    fetchData();<br>    <br>    return () => {<br>      abortController.abort();<br>    };<br>  }, [url]);<br>  <br>  return state;<br>}</code><br><br>6. <strong>useReducer for complex async state</strong>:<br><code>type AsyncAction&lt;T&gt; =<br>  | { type: 'FETCH_INIT' }<br>  | { type: 'FETCH_SUCCESS'; payload: T }<br>  | { type: 'FETCH_FAILURE'; error: Error };<br><br>function asyncReducer&lt;T&gt;(state: RequestState&lt;T&gt;, action: AsyncAction&lt;T&gt;): RequestState&lt;T&gt; {<br>  switch (action.type) {<br>    case 'FETCH_INIT':<br>      return { status: 'loading' };<br>    case 'FETCH_SUCCESS':<br>      return { status: 'success', data: action.payload };<br>    case 'FETCH_FAILURE':<br>      return { status: 'error', error: action.error };<br>    default:<br>      return state;<br>  }<br>}<br><br>function useAsync&lt;T&gt;(initialData?: T) {<br>  const [state, dispatch] = useReducer(<br>    asyncReducer&lt;T&gt;,<br>    initialData !== undefined<br>      ? { status: 'success', data: initialData }<br>      : { status: 'idle' }<br>  );<br>  <br>  const run = useCallback(async (promise: Promise&lt;T&gt;) => {<br>    dispatch({ type: 'FETCH_INIT' });<br>    <br>    try {<br>      const result = await promise;<br>      dispatch({ type: 'FETCH_SUCCESS', payload: result });<br>      return result;<br>    } catch (error) {<br>      dispatch({ <br>        type: 'FETCH_FAILURE', <br>        error: error instanceof Error ? error : new Error(String(error)) <br>      });<br>      throw error;<br>    }<br>  }, []);<br>  <br>  return { state, run };<br>}</code><br><br>7. <strong>Handling async operations with React Query</strong>:<br><code>import { useQuery, useMutation, QueryClient, QueryClientProvider } from 'react-query';<br><br>// Setup<br>const queryClient = new QueryClient();<br><br>// Wrapper component<br>function App() {<br>  return (<br>    &lt;QueryClientProvider client={queryClient}&gt;<br>      &lt;UserProfile userId={1} /&gt;<br>    &lt;/QueryClientProvider&gt;<br>  );<br>}<br><br>// Component using React Query<br>function UserProfile({ userId }: { userId: number }) {<br>  const { data, isLoading, error } = useQuery&lt;User, Error&gt;(<br>    ['user', userId],<br>    () => fetchUserById(userId),<br>    {<br>      staleTime: 60000, // 1 minute<br>      retry: 2<br>    }<br>  );<br>  <br>  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;<br>  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;<br>  if (!data) return &lt;div&gt;No data available&lt;/div&gt;;<br>  <br>  return (<br>    &lt;div&gt;<br>      &lt;h1&gt;{data.name}&lt;/h1&gt;<br>      &lt;p&gt;{data.email}&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>}</code><br><br>Best practices:<br>- Use discriminated unions to model different request states<br>- Properly type API responses with interfaces or types<br>- Handle errors with proper type checking (instanceof Error)<br>- Use AbortController for cancelling fetch requests on unmount<br>- Consider using a library like React Query or SWR for complex data fetching<br>- Always include loading and error states in your UI<br>- Create reusable hooks for common async patterns",
      },
    ],
  },
  {
    id: 'typescript-advanced',
    title: 'Advanced TypeScript Patterns',
    questions: [
      {
        text: 'What are mapped types in TypeScript and how can they be used with React?',
        answer:
          "Mapped types in TypeScript allow you to create new types by transforming the properties of existing types. They're particularly useful in React for manipulating prop types, form state, and more:<br><br>1. <strong>Basic mapped type syntax</strong>:<br><code>// Mapped type that makes all properties optional<br>type Partial&lt;T&gt; = {<br>  [P in keyof T]?: T[P];<br>};<br><br>// Mapped type that makes all properties required<br>type Required&lt;T&gt; = {<br>  [P in keyof T]-?: T[P];<br>};<br><br>// Mapped type that makes all properties readonly<br>type Readonly&lt;T&gt; = {<br>  readonly [P in keyof T]: T[P];<br>};</code><br><br>2. <strong>Custom mapped types for React props</strong>:<br><code>// Make all props optional except the required ones<br>type OptionalExcept&lt;T, K extends keyof T&gt; = Partial&lt;T&gt; & Pick&lt;T, K&gt;;<br><br>interface ButtonProps {<br>  label: string;<br>  onClick: () => void;<br>  variant?: 'primary' | 'secondary';<br>  disabled?: boolean;<br>  size?: 'small' | 'medium' | 'large';<br>}<br><br>// Creating props where only label and onClick are required<br>type MinimalButtonProps = OptionalExcept&lt;ButtonProps, 'label' | 'onClick'&gt;;</code><br><br>3. <strong>Form field state mapping</strong>:<br><code>// Create form state type from model<br>type FormState&lt;T&gt; = {<br>  values: T;<br>  errors: {<br>    [K in keyof T]?: string;<br>  };<br>  touched: {<br>    [K in keyof T]?: boolean;<br>  };<br>};<br><br>interface UserData {<br>  name: string;<br>  email: string;<br>  age: number;<br>}<br><br>// Creates a type with values, errors, and touched fields<br>type UserFormState = FormState&lt;UserData&gt;;</code><br><br>4. <strong>Component prop transformations</strong>:<br><code>// Convert all event handler props to use specific event types<br>type EventHandlers&lt;T&gt; = {<br>  [K in keyof T as K extends `on${string}` ? K : never]: T[K] extends (...args: any[]) => any<br>    ? T[K]<br>    : never;<br>};<br><br>// Extract non-event-handler props<br>type NonEventHandlers&lt;T&gt; = {<br>  [K in keyof T as K extends `on${string}` ? never : K]: T[K];<br>};<br><br>// Usage<br>type ButtonEventHandlers = EventHandlers&lt;ButtonProps&gt;; // Just the onClick<br>type ButtonAttributes = NonEventHandlers&lt;ButtonProps&gt;; // Everything else</code><br><br>5. <strong>Creating component prop getters</strong>:<br><code>// Convert props to getter functions<br>type PropGetters&lt;T&gt; = {<br>  [K in keyof T as `get${Capitalize<string & K>}Props`]: () => T[K] extends object ? T[K] : { value: T[K] };<br>};<br><br>interface InputProps {<br>  value: string;<br>  disabled: boolean;<br>  placeholder: string;<br>}<br><br>// Results in: { getValueProps: () => { value: string }, getDisabledProps: () => { value: boolean }, ... }<br>type InputPropGetters = PropGetters&lt;InputProps&gt;;</code><br><br>6. <strong>Handler prop generation</strong>:<br><code>// Generate onChange handlers for form fields<br>type FormHandlers&lt;T&gt; = {<br>  [K in keyof T as `handle${Capitalize<string & K>}Change`]: (value: T[K]) => void;<br>};<br><br>// Usage with a form component<br>interface UserFormData {<br>  name: string;<br>  email: string;<br>  age: number;<br>}<br><br>type UserFormHandlers = FormHandlers&lt;UserFormData&gt;;<br>// Produces: { handleNameChange: (value: string) => void, handleEmailChange: ... }</code><br><br>7. <strong>React component props modification</strong>:<br><code>// Add common props to all components in a library<br>type WithThemeProps&lt;Props&gt; = Props & {<br>  theme?: 'light' | 'dark';<br>  className?: string;<br>};<br><br>// Apply to all components<br>type ThemedComponents = {<br>  [K in keyof ComponentLibrary]: React.ComponentType&lt;WithThemeProps&lt;React.ComponentProps&lt;ComponentLibrary[K]&gt;&gt;&gt;;<br>};</code><br><br>8. <strong>Creating validator types from models</strong>:<br><code>// Generate validation schema from model<br>type ValidationSchema&lt;T&gt; = {<br>  [K in keyof T]: {<br>    required?: boolean;<br>    min?: number;<br>    max?: number;<br>    pattern?: RegExp;<br>    validate?: (value: T[K]) => boolean | string;<br>  };<br>};<br><br>// Usage<br>type UserValidation = ValidationSchema&lt;UserData&gt;;<br><br>const userValidators: UserValidation = {<br>  name: { required: true, min: 2 },<br>  email: { required: true, pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/ },<br>  age: { min: 18, max: 100 }<br>};</code><br><br>9. <strong>Creating dynamic style props</strong>:<br><code>// For a styled component system<br>type MarginProps = {<br>  [K in 'margin' | 'marginTop' | 'marginRight' | 'marginBottom' | 'marginLeft']?: string | number;<br>};<br><br>type PaddingProps = {<br>  [K in 'padding' | 'paddingTop' | 'paddingRight' | 'paddingBottom' | 'paddingLeft']?: string | number;<br>};<br><br>type ColorProps = {<br>  [K in 'color' | 'backgroundColor' | 'borderColor']?: string;<br>};<br><br>// Combined style props<br>type StyleProps = MarginProps & PaddingProps & ColorProps;<br><br>// Box component with style props<br>const Box: React.FC&lt;StyleProps & { children: React.ReactNode }&gt; = ({ children, ...styleProps }) => {<br>  return &lt;div style={styleProps as React.CSSProperties}&gt;{children}&lt;/div&gt;;<br>};</code><br><br>Mapped types are one of TypeScript's most powerful features for creating flexible, type-safe abstractions, especially when building complex React component libraries and forms.",
      },
      {
        text: 'What are template literal types in TypeScript and how can they be used in React?',
        answer:
          "Template literal types, introduced in TypeScript 4.1, allow you to manipulate string types by combining string literals with other types. They're especially useful in React for creating strongly typed props, events, and more:<br><br>1. <strong>Basic template literal type syntax</strong>:<br><code>type Greeting = `Hello, ${string}!`;<br><br>// This type represents any string that starts with 'Hello, ' and ends with '!'<br>const a: Greeting = 'Hello, World!'; // Valid<br>const b: Greeting = 'Hello, TypeScript!'; // Valid<br>const c: Greeting = 'Hi there!'; // Error</code><br><br>2. <strong>Creating component prop variants</strong>:<br><code>// Size variants with specific values<br>type Size = 'small' | 'medium' | 'large';<br>type Color = 'primary' | 'secondary' | 'danger';<br><br>// Class names for variants<br>type ButtonClassName = `btn-${Size}-${Color}`;<br><br>// Creates: 'btn-small-primary' | 'btn-small-secondary' | ... | 'btn-large-danger'<br>const buttonClass: ButtonClassName = 'btn-small-primary'; // Valid<br>const invalidClass: ButtonClassName = 'btn-tiny-primary'; // Error</code><br><br>3. <strong>Event handler prop names</strong>:<br><code>// Strict event handler naming<br>type EventNames = 'click' | 'change' | 'focus' | 'blur';<br>type EventHandlerName = `on${Capitalize<EventNames>}`;<br><br>// Creates: 'onClick' | 'onChange' | 'onFocus' | 'onBlur'<br>interface ButtonProps {<br>  label: string;<br>  onClick?: () => void; // Valid handler name<br>  // onhover?: () => void; // Would error - not in EventHandlerName type<br>}</code><br><br>4. <strong>Dynamic prop selections</strong>:<br><code>// Pick props that match a pattern<br>type PickByPattern&lt;T, P extends string&gt; = {<br>  [K in keyof T as K extends `${P}${string}` ? K : never]: T[K];<br>};<br><br>interface InputProps {<br>  value: string;<br>  defaultValue: string;<br>  onChange: (value: string) => void;<br>  onBlur: () => void;<br>  placeholder: string;<br>  aria-label: string;<br>  data-testid: string;<br>}<br><br>// Only get props that start with 'on'<br>type InputEventProps = PickByPattern&lt;InputProps, 'on'&gt;;<br>// Results in: { onChange: (value: string) => void; onBlur: () => void; }<br><br>// Only get props that start with 'aria-'<br>type AriaProps = PickByPattern&lt;InputProps, 'aria-'&gt;;<br>// Results in: { 'aria-label': string; }</code><br><br>5. <strong>Creating CSS property types</strong>:<br><code>// Type-safe CSS properties for styled components<br>type CSSProperty = 'margin' | 'padding' | 'border';<br>type CSSDirection = 'Top' | 'Right' | 'Bottom' | 'Left';<br><br>type CSSPropName = CSSProperty | `${CSSProperty}${CSSDirection}`;<br>// Creates: 'margin' | 'marginTop' | 'marginRight' | ... | 'borderLeft'<br><br>// Type-safe style props<br>type StyleProps = {<br>  [K in CSSPropName]?: string | number;<br>};<br><br>const Box: React.FC&lt;StyleProps & { children: React.ReactNode }&gt; = (props) => {<br>  // Implementation<br>};</code><br><br>6. <strong>Flexible API paths</strong>:<br><code>// Type-safe API route builder<br>type Entity = 'users' | 'posts' | 'comments';<br>type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';<br>type APIRoute = `/${Entity}` | `/${Entity}/${string}`;<br><br>// For building route-specific hooks<br>function useAPI&lt;T&gt;(method: HTTPMethod, route: APIRoute) {<br>  // Implementation<br>}<br><br>// Usage<br>const { data } = useAPI&lt;User&gt;('GET', '/users'); // Valid<br>const { data } = useAPI&lt;Post&gt;('GET', '/posts/123'); // Valid<br>// const { data } = useAPI('GET', '/invalid'); // Error - not a valid route</code><br><br>7. <strong>Form field name patterns</strong>:<br><code>// Type-safe form field paths for nested forms<br>type NestedPaths&lt;T, Prefix extends string = ''&gt; = {<br>  [K in keyof T]: T[K] extends object<br>    ? `${Prefix}${string & K}` | `${Prefix}${string & K}.${NestedPaths&lt;T[K], ''>}`<br>    : `${Prefix}${string & K}`;<br>}[keyof T];<br><br>interface UserForm {<br>  name: string;<br>  email: string;<br>  address: {<br>    street: string;<br>    city: string;<br>    zip: string;<br>  };<br>  settings: {<br>    notifications: {<br>      email: boolean;<br>      push: boolean;<br>    };<br>  };<br>}<br><br>// Creates types for all possible field paths<br>type UserFormPath = NestedPaths&lt;UserForm&gt;;<br>// 'name' | 'email' | 'address' | 'address.street' | ... | 'settings.notifications.push'<br><br>// Form component that accepts valid field paths<br>function FormField({ name }: { name: UserFormPath }) {<br>  return &lt;div&gt;Field: {name}&lt;/div&gt;;<br>}<br><br>// Usage<br>&lt;FormField name=\"name\" /&gt;; // Valid<br>&lt;FormField name=\"address.city\" /&gt;; // Valid<br>&lt;FormField name=\"settings.notifications.email\" /&gt;; // Valid<br>// &lt;FormField name=\"address.country\" /&gt;; // Error - field doesn't exist</code><br><br>8. <strong>Type-safe data attributes</strong>:<br><code>// Type-safe data attributes for component props<br>type DataAttribute = `data-${string}`;<br><br>// Extract all data attributes from props<br>type DataAttributes&lt;T&gt; = {<br>  [K in keyof T as K extends DataAttribute ? K : never]: T[K];<br>};<br><br>// Allow any data attribute in component props<br>interface ButtonProps extends React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {<br>  label: string;<br>  [key: DataAttribute]: string | number | boolean;<br>}<br><br>// Valid usage<br>const button = &lt;Button label=\"Click me\" data-testid=\"submit-button\" data-tracking=\"signup-flow\" /&gt;;</code><br><br>9. <strong>Action type creators</strong>:<br><code>// Type-safe Redux action types<br>type ActionType&lt;T extends string, P extends string&gt; = `${T}/${P}`;<br><br>// Define domains and actions<br>type UserDomain = 'user';<br>type UserAction = 'login' | 'logout' | 'update';<br><br>type PostDomain = 'post';<br>type PostAction = 'create' | 'fetch' | 'delete';<br><br>// Create domain-specific action types<br>type UserActionType = ActionType&lt;UserDomain, UserAction&gt;;<br>// 'user/login' | 'user/logout' | 'user/update'<br><br>type PostActionType = ActionType&lt;PostDomain, PostAction&gt;;<br>// 'post/create' | 'post/fetch' | 'post/delete'<br><br>// All valid action types<br>type AppActionType = UserActionType | PostActionType;<br><br>// Type-safe action creator<br>function createAction&lt;T extends AppActionType, P&gt;(type: T, payload: P) {<br>  return { type, payload };<br>}<br><br>// Usage<br>const loginAction = createAction('user/login', { username: 'john', password: '123' });<br>// const invalidAction = createAction('user/invalid', {}); // Error - not a valid action type</code><br><br>Template literal types are extremely powerful for creating strict, type-safe patterns in React applications, especially when combined with mapped types and other advanced TypeScript features.",
      },
      {
        text: "How do you use the 'keyof' and 'typeof' operators in TypeScript, especially in React applications?",
        answer:
          "The `keyof` and `typeof` operators in TypeScript are powerful tools for creating type-safe code, particularly in React applications:<br><br>1. <strong>The `keyof` operator</strong> - creates a union type of all property keys:<br><code>interface User {<br>  id: number;<br>  name: string;<br>  email: string;<br>}<br><br>// Creates union: 'id' | 'name' | 'email'<br>type UserKey = keyof User;</code><br><br>2. <strong>The `typeof` operator</strong> - gets the type from a value:<br><code>const user = {<br>  id: 1,<br>  name: 'John',<br>  email: 'john@example.com'<br>};<br><br>// Creates equivalent of the User interface above<br>type UserType = typeof user;</code><br><br>3. <strong>Type-safe object property access</strong>:<br><code>function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {<br>  return obj[key];<br>}<br><br>const user = {<br>  id: 1,<br>  name: 'John',<br>  email: 'john@example.com'<br>};<br><br>// Type-safe property access<br>const name = getProperty(user, 'name'); // Type is string<br>const id = getProperty(user, 'id'); // Type is number<br>// const invalid = getProperty(user, 'age'); // Error: 'age' is not in keyof typeof user</code><br><br>4. <strong>Type-safe prop picking in React</strong>:<br><code>interface ButtonProps {<br>  label: string;<br>  onClick: () => void;<br>  variant: 'primary' | 'secondary';<br>  size: 'small' | 'medium' | 'large';<br>  disabled?: boolean;<br>}<br><br>// Create a component that only accepts specific props<br>function PickProps&lt;T, K extends keyof T&gt;(props: Pick&lt;T, K&gt;) {<br>  return props;<br>}<br><br>// Usage<br>const sizeProps = PickProps&lt;ButtonProps, 'size' | 'variant'&gt;({<br>  size: 'medium',<br>  variant: 'primary'<br>});</code><br><br>5. <strong>Creating dynamic lookup types from config</strong>:<br><code>const CONFIG = {<br>  api: 'https://api.example.com',<br>  timeout: 3000,<br>  retries: 3,<br>  environment: 'production' as 'development' | 'staging' | 'production'<br>} as const; // 'as const' preserves the literal types<br><br>// Type of the config object<br>type ConfigType = typeof CONFIG;<br><br>// Type-safe config access<br>function getConfig&lt;K extends keyof ConfigType&gt;(key: K): ConfigType[K] {<br>  return CONFIG[key];<br>}<br><br>// Usage<br>const api = getConfig('api'); // Type is 'https://api.example.com'<br>const env = getConfig('environment'); // Type is 'development' | 'staging' | 'production'<br>// const invalid = getConfig('debug'); // Error: 'debug' is not in keyof typeof CONFIG</code><br><br>6. <strong>Type-safe event handlers in React</strong>:<br><code>type InputEvent = <br>  | { type: 'change'; value: string }<br>  | { type: 'focus' }<br>  | { type: 'blur' };<br><br>type InputEventType = InputEvent['type']; // 'change' | 'focus' | 'blur'<br><br>type EventHandlers = {<br>  [K in InputEventType as `on${Capitalize<K>}`]: (event: Extract&lt;InputEvent, { type: K }&gt;) => void;<br>};<br><br>// Results in:<br>// {<br>//   onChange: (event: { type: 'change'; value: string }) => void;<br>//   onFocus: (event: { type: 'focus' }) => void;<br>//   onBlur: (event: { type: 'blur' }) => void;<br>// }</code><br><br>7. <strong>Creating a type-safe theme system</strong>:<br><code>// Define theme object<br>const theme = {<br>  colors: {<br>    primary: '#0070f3',<br>    secondary: '#ff4081',<br>    success: '#2e7d32',<br>    error: '#d32f2f',<br>    background: '#ffffff',<br>    text: '#333333'<br>  },<br>  spacing: {<br>    small: '4px',<br>    medium: '8px',<br>    large: '16px',<br>    xlarge: '32px'<br>  },<br>  typography: {<br>    fontFamily: 'Arial, sans-serif',<br>    fontSize: {<br>      small: '12px',<br>      medium: '16px',<br>      large: '20px',<br>      xlarge: '24px'<br>    }  <br>  }<br>} as const;<br><br>// Get theme type<br>type Theme = typeof theme;<br><br>// Create types for theme paths<br>type ThemeColorKey = keyof Theme['colors'];<br>type ThemeSpacingKey = keyof Theme['spacing'];<br>type ThemeFontSizeKey = keyof Theme['typography']['fontSize'];<br><br>// Type-safe theme component<br>interface StyledProps {<br>  color?: ThemeColorKey;<br>  padding?: ThemeSpacingKey;<br>  fontSize?: ThemeFontSizeKey;<br>}<br><br>function Box({ color = 'primary', padding = 'medium', fontSize = 'medium', children }: StyledProps & { children: React.ReactNode }) {<br>  return (<br>    &lt;div<br>      style={{<br>        color: theme.colors[color],<br>        padding: theme.spacing[padding],<br>        fontSize: theme.typography.fontSize[fontSize]<br>      }}<br>    &gt;<br>      {children}<br>    &lt;/div&gt;<br>  );<br>}</code><br><br>8. <strong>Type-safe Redux actions from constants</strong>:<br><code>// Define action types as constants<br>const ActionTypes = {<br>  ADD_TODO: 'ADD_TODO',<br>  TOGGLE_TODO: 'TOGGLE_TODO',<br>  SET_FILTER: 'SET_FILTER'<br>} as const;<br><br>// Get type from constants<br>type ActionType = typeof ActionTypes[keyof typeof ActionTypes];<br>// 'ADD_TODO' | 'TOGGLE_TODO' | 'SET_FILTER'<br><br>// Type-safe action creator<br>function createAction&lt;T extends ActionType, P&gt;(type: T, payload: P) {<br>  return { type, payload };<br>}<br><br>// Usage<br>const addTodo = createAction(ActionTypes.ADD_TODO, { text: 'Learn TypeScript' });</code><br><br>9. <strong>Type-safe form field access</strong>:<br><code>interface FormValues {<br>  name: string;<br>  email: string;<br>  age: number;<br>  address: {<br>    street: string;<br>    city: string;<br>  };<br>}<br><br>// Type-safe form component<br>function Form() {<br>  const [values, setValues] = useState&lt;FormValues&gt;({<br>    name: '',<br>    email: '',<br>    age: 0,<br>    address: { street: '', city: '' }<br>  });<br>  <br>  // Type-safe field updater<br>  function updateField&lt;K extends keyof FormValues&gt;(key: K, value: FormValues[K]) {<br>    setValues(prev => ({ ...prev, [key]: value }));<br>  }<br>  <br>  // Usage<br>  return (<br>    &lt;form&gt;<br>      &lt;input <br>        value={values.name} <br>        onChange={e => updateField('name', e.target.value)} <br>      /&gt;<br>      &lt;input <br>        value={values.email} <br>        onChange={e => updateField('email', e.target.value)} <br>      /&gt;<br>      &lt;input <br>        type=\"number\" <br>        value={values.age} <br>        onChange={e => updateField('age', Number(e.target.value))} <br>      /&gt;<br>    &lt;/form&gt;<br>  );<br>}</code><br><br>The `keyof` and `typeof` operators are fundamental to creating flexible, type-safe abstractions in TypeScript and React. They allow you to create dynamic yet strictly typed patterns that catch errors at compile time rather than runtime.",
      },
      {
        text: 'What are utility types in TypeScript and which ones are most useful for React development?',
        answer:
          "Utility types in TypeScript are pre-defined generic types that help with common type transformations. They're extremely useful in React development for handling props, state, and more:<br><br>1. <strong>Partial&lt;T&gt;</strong> - makes all properties optional:<br><code>// Useful for partial state updates<br>interface User {<br>  id: number;<br>  name: string;<br>  email: string;<br>}<br><br>function updateUser(id: number, userData: Partial&lt;User&gt;) {<br>  // Can update just some fields<br>  // userData may contain any subset of User properties<br>}<br><br>updateUser(1, { name: 'John' }); // Valid, don't need to provide all fields</code><br><br>2. <strong>Required&lt;T&gt;</strong> - makes all properties required:<br><code>// Enforce required fields for internal implementations<br>interface Config {<br>  endpoint?: string;<br>  timeout?: number;<br>  retries?: number;<br>}<br><br>// Internal function that requires all fields to be set<br>function initializeApi(config: Required&lt;Config&gt;) {<br>  // All properties are guaranteed to exist<br>}</code><br><br>3. <strong>Pick&lt;T, K&gt;</strong> - picks specific properties:<br><code>// Create subset of props for specialized components<br>interface ButtonProps {<br>  label: string;<br>  onClick: () => void;<br>  disabled?: boolean;<br>  variant?: 'primary' | 'secondary';<br>  size?: 'small' | 'medium' | 'large';<br>}<br><br>// Only need label and onClick props<br>type MinimalButtonProps = Pick&lt;ButtonProps, 'label' | 'onClick'&gt;;<br><br>function SimpleButton({ label, onClick }: MinimalButtonProps) {<br>  return &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;;<br>}</code><br><br>4. <strong>Omit&lt;T, K&gt;</strong> - removes specific properties:<br><code>// Create component with all props except some<br>interface InputProps {<br>  value: string;<br>  onChange: (value: string) => void;<br>  disabled?: boolean;<br>  placeholder?: string;<br>  type: 'text' | 'password' | 'email';<br>}<br><br>// Create a text-only input without the type prop<br>type TextInputProps = Omit&lt;InputProps, 'type'&gt;;<br><br>function TextInput(props: TextInputProps) {<br>  // type is not included in props<br>  return &lt;input type=\"text\" {...props} /&gt;;<br>}</code><br><br>5. <strong>Record&lt;K, T&gt;</strong> - creates an object type with keys of K and values of T:<br><code>// Type-safe dictionaries/maps<br>type ValidRoutes = 'home' | 'profile' | 'settings';<br><br>// Map of components for each route<br>const routeComponents: Record&lt;ValidRoutes, React.ComponentType&gt; = {<br>  home: HomePage,<br>  profile: ProfilePage,<br>  settings: SettingsPage<br>};</code><br><br>6. <strong>Exclude&lt;T, U&gt;</strong> - removes types from T that are assignable to U:<br><code>// Remove specific options from a union<br>type ButtonVariant = 'primary' | 'secondary' | 'success' | 'danger' | 'warning';<br><br>// Create type without warning and danger<br>type SafeButtonVariant = Exclude&lt;ButtonVariant, 'danger' | 'warning'&gt;;<br>// 'primary' | 'secondary' | 'success'</code><br><br>7. <strong>Extract&lt;T, U&gt;</strong> - extracts types from T that are assignable to U:<br><code>// Extract specific types from a union<br>type FormElement = <br>  | { type: 'input'; value: string }<br>  | { type: 'checkbox'; checked: boolean }<br>  | { type: 'select'; selected: string };<br><br>// Get only the checkbox type<br>type CheckboxElement = Extract&lt;FormElement, { type: 'checkbox' }&gt;;<br>// { type: 'checkbox'; checked: boolean }</code><br><br>8. <strong>NonNullable&lt;T&gt;</strong> - removes null and undefined from T:<br><code>// Ensure value is not null or undefined<br>function renderUserName(name: string | null | undefined) {<br>  const userName: NonNullable&lt;typeof name&gt; = name ?? 'Guest';<br>  return &lt;span&gt;{userName}&lt;/span&gt;;<br>}</code><br><br>9. <strong>ReturnType&lt;T&gt;</strong> - extracts the return type of a function:<br><code>// Get the return type of a function<br>function useUser(id: number) {<br>  const [user, setUser] = useState({<br>    id: 0,<br>    name: '',<br>    email: ''<br>  });<br>  <br>  // Other implementation...<br>  <br>  return { user, loading, error, refetch };<br>}<br><br>// Extract return type of the hook<br>type UseUserResult = ReturnType&lt;typeof useUser&gt;;<br><br>// Use in another component<br>function UserProfile({ id }: { id: number }) {<br>  const result: UseUserResult = useUser(id);<br>  // Type-safe access to user, loading, error, refetch<br>}</code><br><br>10. <strong>Parameters&lt;T&gt;</strong> - extracts parameter types of a function:<br><code>// Extract parameter types of a component<br>function Button({ label, onClick }: { label: string; onClick?: () => void }) {<br>  return &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;;<br>}<br><br>// Get the props type<br>type ButtonProps = Parameters&lt;typeof Button&gt;[0];<br><br>// Use in another component<br>function EnhancedButton(props: ButtonProps) {<br>  return &lt;Button {...props} className=\"enhanced\" /&gt;;<br>}</code><br><br>11. <strong>Readonly&lt;T&gt;</strong> - makes all properties readonly:<br><code>// Ensure props are not modified<br>interface User {<br>  id: number;<br>  name: string;<br>}<br><br>function UserDisplay({ user }: { user: Readonly&lt;User&gt; }) {<br>  // This would cause an error:<br>  // user.name = 'New name';<br>  <br>  return &lt;div&gt;{user.name}&lt;/div&gt;;<br>}</code><br><br>12. <strong>ReadonlyArray&lt;T&gt;</strong> - a readonly array of type T:<br><code>// Prevent array mutations<br>function ItemList({ items }: { items: ReadonlyArray&lt;string&gt; }) {<br>  // This would cause an error:<br>  // items.push('new item');<br>  <br>  return (<br>    &lt;ul&gt;<br>      {items.map(item => &lt;li key={item}&gt;{item}&lt;/li&gt;)}<br>    &lt;/ul&gt;<br>  );<br>}</code><br><br>13. <strong>InstanceType&lt;T&gt;</strong> - extracts the instance type of a class constructor:<br><code>// Useful for class components<br>class UserService {<br>  getUser(id: number) {<br>    return { id, name: 'User ' + id };<br>  }<br>}<br><br>// Get instance type<br>type UserServiceInstance = InstanceType&lt;typeof UserService&gt;;<br><br>function useUserService() {<br>  const serviceRef = useRef&lt;UserServiceInstance | null&gt;(null);<br>  <br>  if (serviceRef.current === null) {<br>    serviceRef.current = new UserService();<br>  }<br>  <br>  return serviceRef.current;<br>}</code><br><br>14. <strong>ThisType&lt;T&gt;</strong> - marker for contextual 'this' type:<br><code>// Used for object methods with specific this context<br>interface ButtonMethods {<br>  toggle(): void;<br>  enable(): void;<br>  disable(): void;<br>}<br><br>interface ButtonState {<br>  isEnabled: boolean;<br>  isActive: boolean;<br>}<br><br>// Methods use state properties via 'this'<br>const buttonConfig: ButtonMethods & ThisType&lt;ButtonState&gt; = {<br>  toggle() {<br>    this.isActive = !this.isActive;<br>  },<br>  enable() {<br>    this.isEnabled = true;<br>  },<br>  disable() {<br>    this.isEnabled = false;<br>  }<br>};</code><br><br>Utility types are indispensable for React development, making it easier to define and transform prop types, handle state updates, and create reusable type-safe components and hooks.",
      },
      {
        text: 'How do you implement type-safe higher-order components (HOCs) in React with TypeScript?',
        answer:
          "Implementing type-safe higher-order components (HOCs) in React with TypeScript requires careful consideration of generic types to ensure proper prop typing and type inference. Here's a comprehensive approach:<br><br>1. <strong>Basic type-safe HOC pattern</strong>:<br><code>import React, { ComponentType } from 'react';<br><br>// HOC with additional props<br>function withLoading&lt;P extends object&gt;(Component: ComponentType&lt;P&gt;) {<br>  // Define props for the wrapped component<br>  type WithLoadingProps = P & { loading?: boolean };<br>  <br>  // Return wrapped component with correct typing<br>  return function WithLoading(props: WithLoadingProps) {<br>    const { loading, ...restProps } = props;<br>    <br>    if (loading) {<br>      return &lt;div&gt;Loading...&lt;/div&gt;;<br>    }<br>    <br>    // Cast restProps to P because we've removed the loading prop<br>    return &lt;Component {...(restProps as P)} /&gt;;<br>  };<br>}<br><br>// Usage<br>interface UserProps {<br>  name: string;<br>  email: string;<br>}<br><br>const UserComponent = (props: UserProps) => (<br>  &lt;div&gt;<br>    &lt;h1&gt;{props.name}&lt;/h1&gt;<br>    &lt;p&gt;{props.email}&lt;/p&gt;<br>  &lt;/div&gt;<br>);<br><br>// Enhanced component has properly typed props (UserProps & { loading?: boolean })<br>const UserWithLoading = withLoading(UserComponent);<br><br>// Correct usage<br>&lt;UserWithLoading name=\"John\" email=\"john@example.com\" loading={true} /&gt;</code><br><br>2. <strong>Preserving component display name</strong>:<br><code>function withLoading&lt;P extends object&gt;(Component: ComponentType&lt;P&gt;) {<br>  type WithLoadingProps = P & { loading?: boolean };<br>  <br>  function WithLoading(props: WithLoadingProps) {<br>    // HOC implementation<br>  }<br>  <br>  // Set proper display name for debugging<br>  const displayName = Component.displayName || Component.name || 'Component';<br>  WithLoading.displayName = `withLoading(${displayName})`;<br>  <br>  return WithLoading;<br>}</code><br><br>3. <strong>HOC that injects props</strong>:<br><code>// HOC that injects theme props<br>interface ThemeProps {<br>  theme: {<br>    primaryColor: string;<br>    secondaryColor: string;<br>  };<br>}<br><br>// HOC that adds theme props to wrapped component<br>function withTheme&lt;P extends object&gt;(Component: ComponentType&lt;P & ThemeProps&gt;) {<br>  // Return component that doesn't need theme props externally<br>  return function WithTheme(props: P) {<br>    // Theme could come from a context or configuration<br>    const theme = {<br>      primaryColor: '#0070f3',<br>      secondaryColor: '#ff4081'<br>    };<br>    <br>    // Pass both the original props and injected theme prop<br>    return &lt;Component {...props} theme={theme} /&gt;;<br>  };<br>}<br><br>// Component that requires theme<br>interface ButtonProps {<br>  label: string;<br>  onClick: () => void;<br>}<br><br>// This component expects to receive ThemeProps<br>const ThemedButton = ({ label, onClick, theme }: ButtonProps & ThemeProps) => (<br>  &lt;button<br>    onClick={onClick}<br>    style={{ backgroundColor: theme.primaryColor }}<br>  &gt;<br>    {label}<br>  &lt;/button&gt;<br>);<br><br>// Enhanced component has properly typed props (just ButtonProps)<br>const ButtonWithTheme = withTheme(ThemedButton);<br><br>// Usage (theme props are injected by HOC)<br>&lt;ButtonWithTheme label=\"Click me\" onClick={() => {}} /&gt;</code><br><br>4. <strong>HOC that connects to a store or context</strong>:<br><code>// Store state type<br>interface AppState {<br>  user: {<br>    id: number;<br>    name: string;<br>    isAuthenticated: boolean;<br>  };<br>}<br><br>// Define mapping functions for the HOC<br>type MapState&lt;SelectedState&gt; = (state: AppState) => SelectedState;<br>type MapDispatch&lt;SelectedActions&gt; = (dispatch: (action: any) => void) => SelectedActions;<br><br>// Typed connect HOC<br>function connect&lt;SelectedState, SelectedActions, OwnProps = {}&gt;(<br>  mapState: MapState&lt;SelectedState&gt;,<br>  mapDispatch: MapDispatch&lt;SelectedActions&gt;<br>) {<br>  // Return the actual HOC<br>  return function connectHOC&lt;P extends SelectedState & SelectedActions&gt;(<br>    Component: ComponentType&lt;P&gt;<br>  ) {<br>    // Result component only requires OwnProps<br>    type ConnectedProps = OwnProps & Omit&lt;P, keyof (SelectedState & SelectedActions)&gt;;<br>    <br>    // Return connected component<br>    return function ConnectedComponent(props: ConnectedProps) {<br>      // In real app, these would come from a real store/context<br>      const state = mapState({ <br>        user: { id: 1, name: 'User', isAuthenticated: true } <br>      } as AppState);<br>      <br>      const actions = mapDispatch(action => console.log(action));<br>      <br>      // Combine props with mapped state and actions<br>      return &lt;Component {...props} {...state} {...actions} /&gt;;<br>    };<br>  };<br>}<br><br>// Component that requires data and actions<br>interface UserViewProps {<br>  // From mapState<br>  userName: string;<br>  isAuthenticated: boolean;<br>  <br>  // From mapDispatch<br>  logout: () => void;<br>  <br>  // Own props<br>  showDetails: boolean;<br>}<br><br>const UserView = ({ <br>  userName, <br>  isAuthenticated,<br>  logout,<br>  showDetails <br>}: UserViewProps) => (<br>  &lt;div&gt;<br>    {isAuthenticated ? (<br>      &lt;&gt;<br>        &lt;p&gt;Welcome, {userName}!&lt;/p&gt;<br>        {showDetails && &lt;p&gt;More user details...&lt;/p&gt;}<br>        &lt;button onClick={logout}&gt;Logout&lt;/button&gt;<br>      &lt;/&gt;<br>    ) : (<br>      &lt;p&gt;Please log in&lt;/p&gt;<br>    )}<br>  &lt;/div&gt;<br>);<br><br>// Define mappings<br>const mapState = (state: AppState) => ({<br>  userName: state.user.name,<br>  isAuthenticated: state.user.isAuthenticated<br>});<br><br>const mapDispatch = (dispatch: any) => ({<br>  logout: () => dispatch({ type: 'LOGOUT' })<br>});<br><br>// Create connected component<br>const ConnectedUserView = connect(mapState, mapDispatch)(UserView);<br><br>// Usage - only needs to provide the own props<br>&lt;ConnectedUserView showDetails={true} /&gt;</code><br><br>5. <strong>Handling ref forwarding in HOCs</strong>:<br><code>// HOC with ref forwarding<br>function withStyles&lt;P extends object, T extends HTMLElement&gt;(<br>  Component: React.ForwardRefExoticComponent&lt;React.PropsWithoutRef&lt;P&gt; & React.RefAttributes&lt;T&gt;&gt;<br>) {<br>  type StyleProps = P & { className?: string };<br>  <br>  // Create forwarding ref component<br>  return React.forwardRef&lt;T, StyleProps&gt;((props, ref) => {<br>    const { className, ...rest } = props;<br>    const styleClassName = `styled-component ${className || ''}`;<br>    <br>    return &lt;Component {...(rest as P)} className={styleClassName} ref={ref} /&gt;;<br>  });<br>}<br><br>// Base component with ref<br>const Button = React.forwardRef&lt;HTMLButtonElement, { onClick: () => void; label: string }&gt;(<br>  (props, ref) => (<br>    &lt;button ref={ref} onClick={props.onClick}&gt;<br>      {props.label}<br>    &lt;/button&gt;<br>  )<br>);<br><br>// Enhanced component that preserves ref functionality<br>const StyledButton = withStyles(Button);<br><br>// Usage with ref<br>function App() {<br>  const buttonRef = useRef&lt;HTMLButtonElement&gt;(null);<br>  <br>  useEffect(() => {<br>    if (buttonRef.current) {<br>      buttonRef.current.focus();<br>    }<br>  }, []);<br>  <br>  return (<br>    &lt;StyledButton<br>      ref={buttonRef}<br>      label=\"Click me\"<br>      onClick={() => {}}<br>    /&gt;<br>  );<br>}</code><br><br>6. <strong>HOC composition</strong>:<br><code>// Compose multiple HOCs<br>function compose&lt;R&gt;(...funcs: Function[]) {<br>  return funcs.reduce(<br>    (a, b) => (...args: any) => a(b(...args)),<br>    (arg: any) => arg<br>  ) as R;<br>}<br><br>// Usage with multiple HOCs<br>const EnhancedComponent = compose&lt;React.ComponentType&lt;UserProps&gt;&gt;(<br>  withTheme,<br>  withLoading,<br>  connect(mapState, mapDispatch)<br>)(UserComponent);</code><br><br>7. <strong>HOC that controls rendering logic</strong>:<br><code>// HOC for conditional rendering<br>function withAuthorization&lt;P extends object&gt;(Component: ComponentType&lt;P&gt;) {<br>  return function WithAuthorization(props: P) {<br>    // Auth logic would typically use a context or hook<br>    const { isAuthenticated, userRole } = useAuth();<br>    <br>    if (!isAuthenticated) {<br>      return &lt;Redirect to=\"/login\" /&gt;;<br>    }<br>    <br>    if (userRole !== 'admin') {<br>      return &lt;AccessDenied /&gt;;<br>    }<br>    <br>    return &lt;Component {...props} /&gt;;<br>  };<br>}</code><br><br>8. <strong>HOC with hooks (modern approach)</strong>:<br><code>// Modern alternative to HOCs using hooks<br>function useLoading&lt;T&gt;(loadingFn: () => Promise&lt;T&gt;) {<br>  const [data, setData] = useState&lt;T | null&gt;(null);<br>  const [loading, setLoading] = useState(false);<br>  const [error, setError] = useState&lt;Error | null&gt;(null);<br><br>  const load = async () => {<br>    setLoading(true);<br>    try {<br>      const result = await loadingFn();<br>      setData(result);<br>      setError(null);<br>    } catch (e) {<br>      setError(e as Error);<br>    } finally {<br>      setLoading(false);<br>    }<br>  };<br><br>  return { data, loading, error, load };<br>}<br><br>// Higher-order hook for data fetching<br>function withData&lt;T, P extends object&gt;(<br>  Component: ComponentType&lt;P & { data: T | null; loading: boolean; error: Error | null }&gt;,<br>  fetchData: () => Promise&lt;T&gt;<br>) {<br>  return function WithData(props: P) {<br>    const { data, loading, error } = useLoading(fetchData);<br>    <br>    // Use useEffect to load data on mount<br>    useEffect(() => {<br>      load();<br>    }, []);<br>    <br>    return (<br>      &lt;Component<br>        {...props}<br>        data={data}<br>        loading={loading}<br>        error={error}<br>      /&gt;<br>    );<br>  };<br>}</code><br><br>When working with HOCs in TypeScript, the key is to carefully manage the relationship between input props and output props using generics, making sure component consumers get the correct type checking for the enhanced components.",
      },
    ],
  },
  {
    id: 'typescript-performance',
    title: 'TypeScript Performance Optimization',
    questions: [
      {
        text: 'How can TypeScript improve React application performance?',
        answer:
          "TypeScript can contribute to React application performance in several ways:<br><br>1. <strong>Compile-time optimizations</strong>:<br>- <strong>Early error detection</strong>: TypeScript catches type errors during development rather than at runtime, reducing bugs and unexpected behaviors that could cause performance issues.<br>- <strong>Code editor optimizations</strong>: TypeScript enables better IDE support, including code completion and navigation, which can help developers write more efficient code.<br>- <strong>Build-time checks</strong>: TypeScript can identify unused imports, variables, and functions, which might lead to smaller bundle sizes when used with proper tree-shaking.<br><br>2. <strong>Memoization with proper typing</strong>:<br><code>// Type-safe memoization with React.memo<br>interface ProductItemProps {<br>  id: number;<br>  name: string;<br>  price: number;<br>  onAddToCart: (id: number) => void;<br>}<br><br>// The component with type-safe props<br>const ProductItem = ({ id, name, price, onAddToCart }: ProductItemProps) => {<br>  console.log(`Rendering product ${id}`);<br>  <br>  return (<br>    &lt;div className=\"product\"&gt;<br>      &lt;h3&gt;{name}&lt;/h3&gt;<br>      &lt;p&gt;${price.toFixed(2)}&lt;/p&gt;<br>      &lt;button onClick={() => onAddToCart(id)}&gt;Add to Cart&lt;/button&gt;<br>    &lt;/div&gt;<br>  );<br>};<br><br>// Memoized component with proper typing<br>const MemoizedProductItem = React.memo(ProductItem);<br><br>// For more control over re-renders<br>const areEqual = (<br>  prevProps: ProductItemProps,<br>  nextProps: ProductItemProps<br>) => {<br>  // Only re-render if these props change<br>  return (<br>    prevProps.id === nextProps.id &&<br>    prevProps.name === nextProps.name &&<br>    prevProps.price === nextProps.price<br>    // Intentionally omitting onAddToCart function<br>  );<br>};<br><br>const OptimizedProductItem = React.memo(ProductItem, areEqual);</code><br><br>3. <strong>Typed useMemo and useCallback</strong>:<br><code>interface User {<br>  id: number;<br>  name: string;<br>  email: string;<br>}<br><br>function UserProfile({ userId }: { userId: number }) {<br>  const [user, setUser] = useState&lt;User | null&gt;(null);<br>  <br>  // Memoized expensive calculation with proper typing<br>  const userStats = useMemo&lt;{ totalPosts: number; joinedDays: number }&gt;(() => {<br>    if (!user) return { totalPosts: 0, joinedDays: 0 };<br>    <br>    // Pretend this is expensive<br>    const totalPosts = calculateTotalPosts(user);<br>    const joinedDays = calculateDaysSinceJoined(user);<br>    <br>    return { totalPosts, joinedDays };<br>  }, [user]); // Only recalculate when user changes<br>  <br>  // Typed callback that won't trigger unnecessary re-renders<br>  const handleUpdateUser = useCallback((data: Partial&lt;User&gt;) => {<br>    setUser(prevUser => prevUser ? { ...prevUser, ...data } : null);<br>  }, []);<br>  <br>  // Rest of component...<br>}</code><br><br>4. <strong>Avoiding unnecessary renders with discriminated unions</strong>:<br><code>// State with discriminated union<br>type UserState =<br>  | { status: 'idle' }<br>  | { status: 'loading' }<br>  | { status: 'success'; data: User }<br>  | { status: 'error'; error: string };<br><br>function UserProfile({ userId }: { userId: number }) {<br>  const [state, setState] = useState&lt;UserState&gt;({ status: 'idle' });<br>  <br>  // Separate rendering logic based on state<br>  if (state.status === 'loading') {<br>    return &lt;LoadingSpinner /&gt;;<br>  }<br>  <br>  if (state.status === 'error') {<br>    return &lt;ErrorMessage message={state.error} /&gt;;<br>  }<br>  <br>  if (state.status === 'success') {<br>    return &lt;UserDetails user={state.data} /&gt;;<br>  }<br>  <br>  return &lt;div&gt;Click to load user&lt;/div&gt;;<br>}</code><br><br>5. <strong>Type-safe context optimization</strong>:<br><code>// Split context to avoid unnecessary re-renders<br>interface UserData {<br>  id: number;<br>  name: string;<br>  email: string;<br>}<br><br>interface UserActions {<br>  login: (credentials: { username: string; password: string }) => void;<br>  logout: () => void;<br>  updateProfile: (data: Partial&lt;UserData&gt;) => void;<br>}<br><br>// Separate contexts for data and actions<br>const UserDataContext = createContext&lt;UserData | null&gt;(null);<br>const UserActionsContext = createContext&lt;UserActions | null&gt;(null);<br><br>// Provider that separates concerns<br>function UserProvider({ children }: { children: React.ReactNode }) {<br>  const [userData, setUserData] = useState&lt;UserData | null&gt;(null);<br>  <br>  // Memoize actions to prevent unnecessary context updates<br>  const actions = useMemo&lt;UserActions&gt;(() => {<br>    return {<br>      login: async (credentials) => { /* implementation */ },<br>      logout: () => setUserData(null),<br>      updateProfile: (data) => {<br>        setUserData(prev => prev ? { ...prev, ...data } : null);<br>      }<br>    };<br>  }, []); // Empty deps as these functions don't change<br>  <br>  return (<br>    &lt;UserActionsContext.Provider value={actions}&gt;<br>      &lt;UserDataContext.Provider value={userData}&gt;<br>        {children}<br>      &lt;/UserDataContext.Provider&gt;<br>    &lt;/UserActionsContext.Provider&gt;<br>  );<br>}</code><br><br>6. <strong>Typed lazy loading and code splitting</strong>:<br><code>// Type-safe lazy loading<br>const LazyComponent = React.lazy(() => <br>  import('./HeavyComponent').then(module => ({ default: module.HeavyComponent }))<br>);<br><br>// Ensure proper typing for dynamic imports<br>type ComponentModule&lt;T&gt; = { default: React.ComponentType&lt;T&gt; };<br><br>function lazyLoad&lt;T&gt;(importFn: () => Promise&lt;ComponentModule&lt;T&gt;&gt;) {<br>  return React.lazy(importFn);<br>}<br><br>// Usage<br>interface UserListProps {<br>  filter: string;<br>}<br><br>const UserList = lazyLoad&lt;UserListProps&gt;(() => <br>  import('./UserList')<br>);<br><br>function App() {<br>  return (<br>    &lt;React.Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br>      &lt;UserList filter=\"active\" /&gt;<br>    &lt;/React.Suspense&gt;<br>  );<br>}</code><br><br>7. <strong>TypeScript for optimizing bundle size</strong>:<br><code>// Using TypeScript paths to create micro-frontends or module splitting<br>// tsconfig.json<br>// {<br>//   \"compilerOptions\": {<br>//     \"paths\": {<br>//       \"@core/*\": [\"./src/core/*\"],<br>//       \"@features/*\": [\"./src/features/*\"],<br>//       \"@ui/*\": [\"./src/ui/*\"]<br>//     }<br>//   }<br>// }<br><br>// Import only what's needed<br>import { Button } from '@ui/components';<br>import { useUser } from '@core/hooks';<br>// Instead of: import { Button, Card, Input, ... } from './components';</code><br><br>8. <strong>Typed virtual rendering for large lists</strong>:<br><code>interface ItemData {<br>  id: number;<br>  name: string;<br>}<br><br>interface VirtualListProps {<br>  items: ItemData[];<br>  height: number;<br>  itemHeight: number;<br>  renderItem: (item: ItemData, index: number) => React.ReactNode;<br>}<br><br>// Type-safe virtualized list component<br>function VirtualList({ items, height, itemHeight, renderItem }: VirtualListProps) {<br>  const [scrollTop, setScrollTop] = useState(0);<br>  <br>  // Calculate visible items for performance<br>  const visibleItemCount = Math.ceil(height / itemHeight);<br>  const startIndex = Math.floor(scrollTop / itemHeight);<br>  const endIndex = Math.min(items.length - 1, startIndex + visibleItemCount);<br>  <br>  const visibleItems = useMemo(() => {<br>    return items.slice(startIndex, endIndex + 1);<br>  }, [items, startIndex, endIndex]);<br>  <br>  const handleScroll = (e: React.UIEvent&lt;HTMLDivElement&gt;) => {<br>    setScrollTop(e.currentTarget.scrollTop);<br>  };<br>  <br>  return (<br>    &lt;div<br>      style={{ height, overflow: 'auto' }}<br>      onScroll={handleScroll}<br>    &gt;<br>      &lt;div style={{ height: items.length * itemHeight, position: 'relative' }}&gt;<br>        {visibleItems.map((item, index) => (<br>          &lt;div<br>            key={item.id}<br>            style={{<br>              position: 'absolute',<br>              top: (startIndex + index) * itemHeight,<br>              height: itemHeight<br>            }}<br>          &gt;<br>            {renderItem(item, startIndex + index)}<br>          &lt;/div><br>        ))}<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  );<br>}</code><br><br>9. <strong>Type-safe event delegation</strong>:<br><code>// Event delegation with proper typing<br>type ItemType = 'user' | 'product' | 'category';<br><br>interface DelegatedItemProps {<br>  items: Array&lt;{ id: number; type: ItemType; name: string }&gt;;<br>  onItemClick: (id: number, type: ItemType) => void;<br>}<br><br>// Using event delegation for better performance<br>function ItemList({ items, onItemClick }: DelegatedItemProps) {<br>  // Single event handler for all items<br>  const handleClick = useCallback((e: React.MouseEvent&lt;HTMLUListElement&gt;) => {<br>    const target = e.target as HTMLElement;<br>    const listItem = target.closest('[data-id]');<br>    <br>    if (listItem) {<br>      const id = Number(listItem.getAttribute('data-id'));<br>      const type = listItem.getAttribute('data-type') as ItemType;<br>      onItemClick(id, type);<br>    }<br>  }, [onItemClick]);<br>  <br>  return (<br>    &lt;ul onClick={handleClick}&gt;<br>      {items.map(item => (<br>        &lt;li <br>          key={item.id}<br>          data-id={item.id}<br>          data-type={item.type}<br>        &gt;<br>          {item.name}<br>        &lt;/li&gt;<br>      ))}<br>    &lt;/ul&gt;<br>  );<br>}</code><br><br>TypeScript's role in performance is mainly indirectâ€”it helps developers write more maintainable, error-free code with clear interfaces and type safety, which often leads to better performance due to fewer bugs and more intentional optimizations.",
      },
      {
        text: 'How do you type React.memo, useMemo, and useCallback for optimal performance?',
        answer:
          "Properly typing `React.memo`, `useMemo`, and `useCallback` is essential for both type safety and optimal performance in React applications:<br><br>1. <strong>Typing React.memo</strong>:<br><code>import React, { memo } from 'react';<br><br>// Define component props with interface<br>interface UserCardProps {<br>  id: number;<br>  name: string;<br>  email: string;<br>  onSelect: (id: number) => void;<br>}<br><br>// Regular component with explicit typing<br>const UserCard = ({ id, name, email, onSelect }: UserCardProps) => {<br>  console.log(`Rendering UserCard for ${name}`);<br>  <br>  return (<br>    &lt;div onClick={() => onSelect(id)}&gt;<br>      &lt;h3&gt;{name}&lt;/h3&gt;<br>      &lt;p&gt;{email}&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>};<br><br>// Basic memoization - infers types from the component<br>const MemoizedUserCard = memo(UserCard);<br><br>// With custom equality function - explicit typing required<br>const customEqual = (<br>  prevProps: UserCardProps,<br>  nextProps: UserCardProps<br>) => {<br>  // Only compare props we care about for rendering<br>  return (<br>    prevProps.id === nextProps.id &&<br>    prevProps.name === nextProps.name &&<br>    prevProps.email === nextProps.email<br>    // Intentionally not comparing the function prop<br>  );<br>};<br><br>// Memoized with custom equality check<br>const OptimizedUserCard = memo(UserCard, customEqual);<br><br>// Usage<br>function UserList() {<br>  // The memoized component has the same prop types as the original<br>  return (<br>    &lt;div&gt;<br>      &lt;MemoizedUserCard<br>        id={1}<br>        name=\"John Doe\"<br>        email=\"john@example.com\"<br>        onSelect={(id) => console.log(`Selected ${id}`)}<br>      /&gt;<br>    &lt;/div&gt;<br>  );<br>}</code><br><br>2. <strong>Typing useMemo for values</strong>:<br><code>// Basic useMemo with inferred type<br>function UserStats({ user }: { user: User }) {<br>  // TypeScript infers the correct return type<br>  const fullName = useMemo(() => {<br>    return `${user.firstName} ${user.lastName}`;<br>  }, [user.firstName, user.lastName]);<br>  <br>  // For complex calculations, explicit typing is helpful<br>  interface Stats {<br>    postsCount: number;<br>    commentsCount: number;<br>    lastActiveDate: Date;<br>  }<br>  <br>  // Explicit type for complex objects<br>  const userStats = useMemo&lt;Stats&gt;(() => {<br>    // Expensive calculation that returns a Stats object<br>    return {<br>      postsCount: calculatePostsCount(user),<br>      commentsCount: calculateCommentsCount(user),<br>      lastActiveDate: calculateLastActive(user)<br>    };<br>  }, [user]); // Dependency array<br>  <br>  // Optional type and fallback for conditional memoization<br>  const premiumInfo = useMemo&lt;{ tier: string } | null&gt;(() => {<br>    if (user.isPremium) {<br>      return { tier: calculatePremiumTier(user) };<br>    }<br>    return null;<br>  }, [user.isPremium, user.subscriptionData]);<br>  <br>  // Rest of component...  <br>}</code><br><br>3. <strong>Typing useCallback for functions</strong>:<br><code>// Basic useCallback with parameter and return types<br>function ProductList({ products }: { products: Product[] }) {<br>  // Inferred parameter and return types<br>  const handleSelect = useCallback((productId: number) => {<br>    console.log(`Selected product: ${productId}`);<br>  }, []);<br>  <br>  // Explicit function type<br>  type FilterFn = (product: Product) => boolean;<br>  <br>  // useCallback with explicit typing<br>  const filterExpensiveProducts = useCallback&lt;FilterFn&gt;((product) => {<br>    return product.price > 100;<br>  }, []);<br>  <br>  // Complex callback with multiple parameters<br>  interface SortOptions {<br>    field: keyof Product;<br>    direction: 'asc' | 'desc';<br>  }<br>  <br>  const sortProducts = useCallback(<br>    (items: Product[], options: SortOptions): Product[] => {<br>      return [...items].sort((a, b) => {<br>        const valueA = a[options.field];<br>        const valueB = b[options.field];<br>        <br>        if (valueA < valueB) return options.direction === 'asc' ? -1 : 1;<br>        if (valueA > valueB) return options.direction === 'asc' ? 1 : -1;<br>        return 0;<br>      });<br>    },<br>    []<br>  );<br>  <br>  // Event handler with proper event typing<br>  const handleFormSubmit = useCallback(<br>    (e: React.FormEvent&lt;HTMLFormElement&gt;) => {<br>      e.preventDefault();<br>      // Form submission logic<br>    },<br>    []<br>  );<br>  <br>  // Rest of component...<br>}</code><br><br>4. <strong>Combining memo, useMemo, and useCallback</strong>:<br><code>interface DataTableProps {<br>  data: Record&lt;string, any&gt;[];<br>  columns: Array&lt;{<br>    key: string;<br>    title: string;<br>    render?: (value: any, record: Record&lt;string, any&gt;) => React.ReactNode;<br>  }&gt;;<br>  onRowClick?: (record: Record&lt;string, any&gt;, index: number) => void;<br>  sortable?: boolean;<br>}<br><br>const DataTable = memo(({ <br>  data, <br>  columns, <br>  onRowClick, <br>  sortable = false <br>}: DataTableProps) => {<br>  // State for sorting<br>  const [sortKey, setSortKey] = useState&lt;string | null&gt;(null);<br>  const [sortDirection, setSortDirection] = useState&lt;'asc' | 'desc'&gt;('asc');<br>  <br>  // Memoized sort function<br>  const sortFunction = useCallback(<br>    (a: Record&lt;string, any&gt;, b: Record&lt;string, any&gt;): number => {<br>      if (!sortKey) return 0;<br>      <br>      const valueA = a[sortKey];<br>      const valueB = b[sortKey];<br>      <br>      if (valueA < valueB) return sortDirection === 'asc' ? -1 : 1;<br>      if (valueA > valueB) return sortDirection === 'asc' ? 1 : -1;<br>      return 0;<br>    },<br>    [sortKey, sortDirection]<br>  );<br>  <br>  // Memoized sorted data<br>  const sortedData = useMemo(() => {<br>    if (!sortKey) return data;<br>    return [...data].sort(sortFunction);<br>  }, [data, sortKey, sortFunction]);<br>  <br>  // Memoized header renderer<br>  const renderHeaders = useMemo(() => {<br>    return columns.map(column => (<br>      &lt;th <br>        key={column.key}<br>        onClick={() => {<br>          if (sortable) {<br>            if (sortKey === column.key) {<br>              setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');<br>            } else {<br>              setSortKey(column.key);<br>              setSortDirection('asc');<br>            }<br>          }<br>        }}<br>      &gt;<br>        {column.title}<br>        {sortable && sortKey === column.key && (<br>          <span>{sortDirection === 'asc' ? ' â†‘' : ' â†“'}</span><br>        )}<br>      &lt;/th&gt;<br>    ));<br>  }, [columns, sortable, sortKey, sortDirection]);<br>  <br>  // Row click handler<br>  const handleRowClick = useCallback(<br>    (record: Record&lt;string, any&gt;, index: number) => {<br>      if (onRowClick) {<br>        onRowClick(record, index);<br>      }<br>    },<br>    [onRowClick]<br>  );<br>  <br>  return (<br>    &lt;table&gt;<br>      &lt;thead&gt;<br>        &lt;tr&gt;{renderHeaders}&lt;/tr&gt;<br>      &lt;/thead&gt;<br>      &lt;tbody&gt;<br>        {sortedData.map((record, rowIndex) => (<br>          &lt;tr <br>            key={rowIndex}<br>            onClick={() => handleRowClick(record, rowIndex)}<br>          &gt;<br>            {columns.map(column => (<br>              &lt;td key={column.key}&gt;<br>                {column.render <br>                  ? column.render(record[column.key], record)<br>                  : record[column.key]}<br>              &lt;/td&gt;<br>            ))}<br>          &lt;/tr&gt;<br>        ))}<br>      &lt;/tbody&gt;<br>    &lt;/table&gt;<br>  );<br>});<br><br>// Individual cell component that can be memoized<br>interface CellProps {<br>  value: any;<br>  record: Record&lt;string, any&gt;;<br>  render?: (value: any, record: Record&lt;string, any&gt;) => React.ReactNode;<br>}<br><br>const Cell = memo(({ value, record, render }: CellProps) => {<br>  return (<br>    &lt;td&gt;<br>      {render ? render(value, record) : value}<br>    &lt;/td&gt;<br>  );<br>});</code><br><br>5. <strong>Performance optimization with dependency tuples</strong>:<br><code>// Using 'as const' for dependency arrays<br>function SearchResults({ query, filters }: { query: string; filters: SearchFilters }) {<br>  // Dependency tuple preserves literal types<br>  const filtersKey = JSON.stringify(filters) as string;<br>  <br>  // API call function<br>  const fetchResults = useCallback(<br>    async (q: string, f: SearchFilters): Promise&lt;SearchResult[]&gt; => {<br>      const response = await fetch(`/api/search?q=${q}&filters=${encodeURIComponent(JSON.stringify(f))}`);<br>      return response.json();<br>    },<br>    // Use const assertion to treat as literals, not just strings<br>    [/* external dependencies would go here */] as const<br>  );<br>  <br>  // Memoized results<br>  const results = useMemo(<br>    () => fetchResults(query, filters),<br>    // Explicit dependency values<br>    [query, filtersKey, fetchResults] as const<br>  );<br>  <br>  // Rest of component...<br>}</code><br><br>6. <strong>Type-safe memoization for complex patterns</strong>:<br><code>// Type-safe memoization factory<br>function createSelector&lt;State, Selected, Result&gt;(<br>  selector: (state: State) => Selected,<br>  resultFn: (selected: Selected) => Result<br>) {<br>  let lastSelected: Selected | undefined;<br>  let lastResult: Result | undefined;<br>  <br>  return (state: State): Result => {<br>    const selected = selector(state);<br>    <br>    if (lastSelected !== selected) {<br>      lastResult = resultFn(selected);<br>      lastSelected = selected;<br>    }<br>    <br>    return lastResult as Result;<br>  };<br>}<br><br>// Usage in a component<br>function UserProfile({ userId }: { userId: number }) {<br>  const { state } = useAppState(); // Some global state<br>  <br>  // Create selector for user data<br>  const selectUserData = useMemo(<br>    () => createSelector(<br>      (state: AppState) => state.users.byId[userId], // Selector <br>      (user) => ({ // Result function<br>        displayName: `${user.firstName} ${user.lastName}`,<br>        initials: `${user.firstName[0]}${user.lastName[0]}`,<br>        isAdmin: user.roles.includes('admin')<br>      })<br>    ),<br>    [userId]<br>  );<br>  <br>  // Memoized user data<br>  const userData = useMemo(<br>    () => selectUserData(state),<br>    [selectUserData, state]<br>  );<br>  <br>  // Rest of component...<br>}</code><br><br>Properly typing these React performance APIs provides both type safety and clear indications of how dependencies and props are used for memoization, helping catch potential issues during development that could lead to unnecessary re-renders.",
      },
      {
        text: 'What TypeScript patterns can help with code-splitting and lazy-loading in React?',
        answer:
          "TypeScript offers several patterns that enhance code-splitting and lazy-loading in React applications, providing both type safety and performance benefits:<br><br>1. <strong>Type-safe React.lazy and Suspense</strong>:<br><code>import React, { lazy, Suspense } from 'react';<br><br>// Type-safe lazy loading with explicit component type<br>const LazyUserProfile = lazy&lt;React.ComponentType&lt;{ userId: number }&gt;&gt;(<br>  () => import('./UserProfile')<br>);<br><br>function App() {<br>  return (<br>    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br>      {/* Type checking works on lazy component props */}<br>      &lt;LazyUserProfile userId={123} /&gt;<br>    &lt;/Suspense&gt;<br>  );<br>}</code><br><br>2. <strong>Helper for type-safe lazy components</strong>:<br><code>// Type-safe wrapper for lazy-loaded components<br>function lazyLoad&lt;T extends React.ComponentType&lt;any&gt;, I extends { default: T }&gt;(<br>  importFunc: () => Promise&lt;I&gt;<br>) {<br>  return lazy(() => importFunc().then(module => ({ default: module.default })));<br>}<br><br>// Define component props separately<br>interface DashboardProps {<br>  userId: number;<br>  isAdmin: boolean;<br>}<br><br>// Load components with proper typing<br>const Dashboard = lazyLoad&lt;React.ComponentType&lt;DashboardProps&gt;&gt;(<br>  () => import('./Dashboard')<br>);<br><br>// Usage<br>function App({ userId, isAdmin }: { userId: number; isAdmin: boolean }) {<br>  return (<br>    &lt;Suspense fallback={&lt;div&gt;Loading dashboard...&lt;/div&gt;}&gt;<br>      &lt;Dashboard userId={userId} isAdmin={isAdmin} /&gt;<br>    &lt;/Suspense&gt;<br>  );<br>}</code><br><br>3. <strong>Route-based code splitting with TypeScript</strong>:<br><code>// Define route component mapping with proper types<br>interface RouteConfig {<br>  path: string;<br>  component: React.ComponentType&lt;any&gt;;<br>  exact?: boolean;<br>  routes?: RouteConfig[];<br>}<br><br>// Helper for lazy route components<br>function lazyRoute&lt;T extends React.ComponentType&lt;any&gt;&gt;(<br>  importFunc: () => Promise&lt;{ default: T }&gt;<br>): T {<br>  return lazy(importFunc);<br>}<br><br>// Define routes with lazy loading<br>const routes: RouteConfig[] = [<br>  {<br>    path: '/',<br>    exact: true,<br>    component: lazyRoute(() => import('./pages/Home'))<br>  },<br>  {<br>    path: '/users',<br>    component: lazyRoute(() => import('./pages/UserList'))<br>  },<br>  {<br>    path: '/users/:id',<br>    component: lazyRoute(() => import('./pages/UserProfile'))<br>  },<br>  {<br>    path: '/settings',<br>    component: lazyRoute(() => import('./pages/Settings')),<br>    routes: [<br>      {<br>        path: '/settings/profile',<br>        component: lazyRoute(() => import('./pages/ProfileSettings'))<br>      },<br>      {<br>        path: '/settings/notifications',<br>        component: lazyRoute(() => import('./pages/NotificationSettings'))<br>      }<br>    ]<br>  }<br>];<br><br>// Router with suspense<br>function Router() {<br>  return (<br>    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br>      &lt;Routes&gt;<br>        {routes.map((route) => (<br>          &lt;Route<br>            key={route.path}<br>            path={route.path}<br>            element={&lt;route.component /&gt;}<br>          /&gt;<br>        ))}<br>      &lt;/Routes&gt;<br>    &lt;/Suspense&gt;<br>  );<br>}</code><br><br>4. <strong>Dynamic import with type assertion</strong>:<br><code>// Dynamic import for non-React modules<br>interface ApiModule {<br>  fetchData: (id: string) => Promise&lt;any&gt;;<br>  processData: (data: any) => any;<br>}<br><br>async function loadApiModule(): Promise&lt;ApiModule&gt; {<br>  // TypeScript will verify the imported module matches ApiModule interface<br>  const module = await import('./api-module');<br>  return module as ApiModule;<br>}<br><br>function DataLoader({ dataId }: { dataId: string }) {<br>  const [data, setData] = useState(null);<br>  <br>  useEffect(() => {<br>    const loadData = async () => {<br>      // Dynamically load the API module<br>      const api = await loadApiModule();<br>      const rawData = await api.fetchData(dataId);<br>      const processedData = api.processData(rawData);<br>      setData(processedData);<br>    };<br>    <br>    loadData();<br>  }, [dataId]);<br>  <br>  // Component rendering<br>}</code><br><br>5. <strong>Feature flags with dynamic imports</strong>:<br><code>// Type-safe feature flags with lazy loading<br>interface Features {<br>  analytics: boolean;<br>  darkMode: boolean;<br>  newUserProfile: boolean;<br>}<br><br>// Components with their requirements<br>interface FeatureComponents {<br>  Analytics: React.ComponentType | null;<br>  DarkModeToggle: React.ComponentType | null;<br>  UserProfile: React.ComponentType&lt;{ userId: number }&gt; | null;<br>}<br><br>// Dynamically load components based on feature flags<br>async function loadFeatureComponents(features: Features): Promise&lt;FeatureComponents&gt; {<br>  const components: FeatureComponents = {<br>    Analytics: null,<br>    DarkModeToggle: null,<br>    UserProfile: null<br>  };<br>  <br>  // Load components in parallel based on feature flags<br>  const loadPromises: Promise&lt;void&gt;[] = [];<br>  <br>  if (features.analytics) {<br>    loadPromises.push(<br>      import('./features/Analytics').then(module => {<br>        components.Analytics = module.default;<br>      })<br>    );<br>  }<br>  <br>  if (features.darkMode) {<br>    loadPromises.push(<br>      import('./features/DarkModeToggle').then(module => {<br>        components.DarkModeToggle = module.default;<br>      })<br>    );<br>  }<br>  <br>  if (features.newUserProfile) {<br>    loadPromises.push(<br>      import('./features/NewUserProfile').then(module => {<br>        components.UserProfile = module.default;<br>      })<br>    );<br>  } else {<br>    loadPromises.push(<br>      import('./features/LegacyUserProfile').then(module => {<br>        components.UserProfile = module.default;<br>      })<br>    );<br>  }<br>  <br>  await Promise.all(loadPromises);<br>  return components;<br>}</code><br><br>6. <strong>Preloading with type safety</strong>:<br><code>// Type-safe component preloading<br>interface PreloadableComponent&lt;P&gt; {<br>  preload: () => Promise&lt;void&gt;;<br>  Component: React.ComponentType&lt;P&gt;;<br>}<br><br>function createLazyPreloadableComponent&lt;P&gt;(<br>  importFunc: () => Promise&lt;{ default: React.ComponentType&lt;P&gt; }&gt;<br>): PreloadableComponent&lt;P&gt; {<br>  const Component = lazy(importFunc);<br>  <br>  return {<br>    // Preload function that can be called before rendering<br>    preload: async () => {<br>      try {<br>        await importFunc();<br>      } catch (e) {<br>        console.error('Preloading failed:', e);<br>      }<br>    },<br>    Component<br>  };<br>}<br><br>// Usage<br>const preloadableComponents = {<br>  UserProfile: createLazyPreloadableComponent&lt;{ userId: number }&gt;(<br>    () => import('./UserProfile')<br>  ),<br>  Settings: createLazyPreloadableComponent&lt;{ sectionId?: string }&gt;(<br>    () => import('./Settings')<br>  )<br>};<br><br>// Preload on hover or other events<br>function Navigation() {<br>  const handleUserHover = () => {<br>    // Preload when user hovers over the link<br>    preloadableComponents.UserProfile.preload();<br>  };<br>  <br>  return (<br>    &lt;nav&gt;<br>      &lt;a href=\"/profile\" onMouseEnter={handleUserHover}&gt;Profile&lt;/a&gt;<br>      {/* Other navigation... */}<br>    &lt;/nav&gt;<br>  );<br>}<br><br>// Actual component usage with Suspense<br>function App() {<br>  return (<br>    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br>      &lt;preloadableComponents.UserProfile.Component userId={123} /&gt;<br>    &lt;/Suspense&gt;<br>  );<br>}</code><br><br>7. <strong>Dynamic bundles with typed import assertions</strong>:<br><code>// Split bundles by feature area<br>type BundleArea = 'core' | 'admin' | 'reporting' | 'userManagement';<br><br>interface BundleModule&lt;T&gt; {<br>  default: T;<br>}<br><br>// Type-safe bundle loader<br>async function loadBundle&lt;T&gt;(<br>  area: BundleArea,<br>  module: string<br>): Promise&lt;T&gt; {<br>  try {<br>    // Dynamic path construction with types<br>    const imported = await import(`./features/${area}/${module}`);<br>    return (imported as BundleModule&lt;T&gt;).default;<br>  } catch (e) {<br>    console.error(`Failed to load bundle: ${area}/${module}`, e);<br>    throw e;<br>  }<br>}<br><br>// Usage in a component<br>function AdminPanel() {<br>  const [adminComponents, setAdminComponents] = useState&lt;{<br>    UserManager: React.ComponentType&lt;{ orgId: number }&gt; | null;<br>    ReportsViewer: React.ComponentType | null;<br>  }&gt;({<br>    UserManager: null,<br>    ReportsViewer: null<br>  });<br>  <br>  useEffect(() => {<br>    // Load admin bundle components<br>    const loadAdminComponents = async () => {<br>      try {<br>        const [UserManager, ReportsViewer] = await Promise.all([<br>          loadBundle&lt;React.ComponentType&lt;{ orgId: number }&gt;&gt;('admin', 'UserManager'),<br>          loadBundle&lt;React.ComponentType&gt;('admin', 'ReportsViewer')<br>        ]);<br>        <br>        setAdminComponents({ UserManager, ReportsViewer });<br>      } catch (e) {<br>        // Error handling<br>      }<br>    };<br>    <br>    loadAdminComponents();<br>  }, []);<br>  <br>  // Render admin components when loaded<br>  return (<br>    &lt;div&gt;<br>      {adminComponents.UserManager && (<br>        &lt;adminComponents.UserManager orgId={123} /&gt;<br>      )}<br>      <br>      {adminComponents.ReportsViewer && (<br>        &lt;adminComponents.ReportsViewer /&gt;<br>      )}<br>    &lt;/div&gt;<br>  );<br>}</code><br><br>8. <strong>Module federation with TypeScript</strong>:<br><code>// Types for remote modules<br>interface RemoteModuleMap {<br>  checkout: {<br>    CheckoutFlow: React.ComponentType&lt;{<br>      cartId: string;<br>      onComplete: (orderId: string) => void;<br>    }&gt;;<br>    PaymentForm: React.ComponentType&lt;{<br>      amount: number;<br>      currency: string;<br>      onSubmit: (paymentDetails: any) => void;<br>    }&gt;;<br>  };<br>  auth: {<br>    LoginForm: React.ComponentType&lt;{<br>      onSuccess: (token: string) => void;<br>      onError: (error: Error) => void;<br>    }&gt;;<br>    SignupForm: React.ComponentType&lt;{<br>      onSuccess: (userId: string) => void;<br>    }&gt;;<br>  };<br>}<br><br>// Type-safe remote module loader<br>async function loadRemoteModule&lt;<br>  T extends keyof RemoteModuleMap,<br>  K extends keyof RemoteModuleMap[T]<br>&gt;(remote: T, module: K): Promise&lt;RemoteModuleMap[T][K]&gt; {<br>  // In a real app, this would use Module Federation's dynamic imports<br>  // This is a simplified example<br>  const container = window[remote as any];<br>  <br>  // Initialize the sharing scope<br>  await container.init(__webpack_share_scopes__.default);<br>  <br>  // Get the factory function<br>  const factory = await container.get(module as string);<br>  <br>  // Create the module<br>  const Module = factory();<br>  return Module;<br>}</code><br><br>These TypeScript patterns for code-splitting and lazy-loading help ensure type safety while improving performance through dynamic loading, providing a robust foundation for optimizing React applications.",
      },
    ],
  },
  {
    id: 'typescript-best-practices',
    title: 'TypeScript Best Practices in React',
    questions: [
      {
        text: 'What are some TypeScript best practices when working with React?',
        answer:
          "Key TypeScript best practices for React development:<br><br>1. <strong>Props typing</strong>: Use interfaces for component props. Define them separately for reusability.<br><br>2. <strong>Function components over React.FC</strong>: Avoid React.FC in favor of regular function declarations with explicit prop types.<br><br>3. <strong>Discriminated unions for state</strong>: Use for complex state with multiple shapes.<br><code>type RequestState<T> =<br>  | { status: 'idle' }<br>  | { status: 'loading' }<br>  | { status: 'success'; data: T }<br>  | { status: 'error'; error: Error };</code><br><br>4. <strong>Don't overuse generics</strong>: Only use when truly needed for code reuse.<br><br>5. <strong>Type imports and exports</strong>: Use explicit types for imports/exports:<br><code>import type { User } from './types';</code><br><br>6. <strong>Avoid any</strong>: Use unknown for truly unknown types, then use type guards.<br><br>7. <strong>Exhaustive checks</strong>: Ensure all cases are handled:<br><code>function assertNever(x: never): never {<br>  throw new Error('Unexpected object: ' + x);<br>}</code><br><br>8. <strong>Default props</strong>: Use destructuring with defaults in function parameters.<br><br>9. <strong>Extend HTML element props</strong>:<br><code>interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {<br>  variant: 'primary' | 'secondary';<br>}</code><br><br>10. <strong>Use Pick, Omit, Partial</strong>: Leverage utility types for prop transformations.",
      },
      {
        text: 'How do you handle common TypeScript errors in React applications?',
        answer:
          "Strategies for handling common TypeScript errors in React:<br><br>1. <strong>Object is possibly 'undefined'</strong>: Use optional chaining, nullish coalescing, or type guards.<br><code>// Optional chaining<br>const userName = user?.name;<br><br>// Nullish coalescing<br>const displayName = user?.name ?? 'Guest';<br><br>// Type guard<br>if (user) {<br>  console.log(user.name);<br>}</code><br><br>2. <strong>Type '...' is not assignable to type '...'</strong>: Check your type definitions, use type assertions when needed, or create proper interfaces.<br><br>3. <strong>Property '...' does not exist on type '...'</strong>: Properly define interfaces or use Record/index signatures for dynamic properties.<br><code>interface Config {<br>  [key: string]: string | number | boolean;<br>}</code><br><br>4. <strong>No overload matches this call</strong>: Often seen with events or functions. Be explicit about parameter types.<br><br>5. <strong>Cannot find module</strong>: Create proper TypeScript declarations for non-TS modules:<br><code>// file: custom-module.d.ts<br>declare module 'untyped-module' {<br>  export function doSomething(): void;<br>  export default function(): string;<br>}</code><br><br>6. <strong>Type assertions for DOM elements</strong>:<br><code>const inputEl = document.getElementById('input') as HTMLInputElement;</code><br><br>7. <strong>Event handler errors</strong>: Use correct event types:<br><code>const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {<br>  console.log(e.target.value);<br>};</code><br><br>8. <strong>Type narrowing</strong> for complex unions:<br><code>if ('success' in result) {<br>  // Now TypeScript knows this is the success branch<br>}</code><br><br>9. <strong>Third-party library issues</strong>: Use DefinitelyTyped (@types/*) or create custom type definitions.",
      },
      {
        text: 'What are the differences between .tsx and .ts files?',
        answer:
          "Key differences between .tsx and .ts files:<br><br>1. <strong>JSX support</strong>: .tsx files allow writing JSX/React components, while .ts files don't.<br><br>2. <strong>Type assertions</strong>: In .tsx files, you must use 'as' syntax for type assertions:<br><code>// In .tsx files:<br>const element = document.getElementById('root') as HTMLElement;<br><br>// In .ts files, you can also use angle brackets:<br>const element = <HTMLElement>document.getElementById('root');</code><br><br>3. <strong>Generic syntax</strong>: In .tsx files, generic component usage may require extra syntax:<br><code>// In .tsx, use comma or extends to disambiguate from JSX tags<br><List<string> items={['a', 'b']} /><br><List<string,> items={['a', 'b']} /><br><List<T extends string> items={['a', 'b']} /></code><br><br>4. <strong>Compiler options</strong>: .tsx files require jsx compiler option in tsconfig.json to be set to 'react', 'react-jsx', or 'react-jsxdev'.<br><br>5. <strong>Type checking</strong>: .tsx files perform additional JSX-specific type checking for React components, props, and children.<br><br>6. <strong>Import/export behavior</strong>: Both handle module imports and exports the same way.<br><br>Choose .tsx for React components with JSX, and .ts for plain TypeScript code (utilities, services, etc.).",
      },
      {
        text: 'How do you handle API responses with TypeScript in React applications?',
        answer:
          "Best practices for handling API responses with TypeScript in React:<br><br>1. <strong>Define response interfaces</strong>:<br><code>interface User {<br>  id: number;<br>  name: string;<br>  email: string;<br>}<br><br>interface ApiResponse<T> {<br>  data: T;<br>  status: number;<br>  message: string;<br>}</code><br><br>2. <strong>Type async requests</strong>:<br><code>async function fetchUser(id: number): Promise<ApiResponse<User>> {<br>  const response = await fetch(`/api/users/${id}`);<br>  return response.json();<br>}</code><br><br>3. <strong>State typing for API data</strong>:<br><code>type ApiState<T> =<br>  | { status: 'idle' }<br>  | { status: 'loading' }<br>  | { status: 'success'; data: T }<br>  | { status: 'error'; error: Error };</code><br><br>4. <strong>Runtime validation</strong> for guaranteed type safety:<br><code>import { z } from 'zod';<br><br>const UserSchema = z.object({<br>  id: z.number(),<br>  name: z.string(),<br>  email: z.string().email()<br>});<br><br>// Validate response at runtime<br>const data = UserSchema.parse(jsonData);</code><br><br>5. <strong>Generic request hooks</strong>:<br><code>function useApi<T>(url: string) {<br>  const [state, setState] = useState<ApiState<T>>({ status: 'idle' });<br>  // Implementation...<br>  return state;<br>}</code><br><br>6. <strong>Type guards for response checking</strong>:<br><code>function isUserResponse(data: any): data is User {<br>  return (<br>    typeof data === 'object' &&<br>    data !== null &&<br>    'id' in data &&<br>    'name' in data &&<br>    'email' in data<br>  );<br>}</code><br><br>7. <strong>Handle errors properly</strong>:<br><code>try {<br>  const data = await fetchUser(1);<br>  setUser(data);<br>} catch (error) {<br>  setError(error instanceof Error ? error.message : 'Unknown error');<br>}</code>",
      },
      {
        text: 'How do you handle forms with TypeScript in React?',
        answer:
          "Handling forms with TypeScript in React:<br><br>1. <strong>Define form state interface</strong>:<br><code>interface LoginForm {<br>  email: string;<br>  password: string;<br>  rememberMe: boolean;<br>}</code><br><br>2. <strong>Type form events</strong>:<br><code>const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {<br>  const { name, value, type, checked } = e.target;<br>  setFormData(prev => ({<br>    ...prev,<br>    [name]: type === 'checkbox' ? checked : value<br>  }));<br>};</code><br><br>3. <strong>Typed form submission</strong>:<br><code>const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {<br>  e.preventDefault();<br>  // Process form<br>};</code><br><br>4. <strong>Generic form hook</strong>:<br><code>function useForm<T extends Record<string, any>>(initialValues: T) {<br>  const [values, setValues] = useState<T>(initialValues);<br>  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});<br>  <br>  // Handle changes, validation, submission...<br>  <br>  return { values, errors, handleChange, handleSubmit };<br>}</code><br><br>5. <strong>Form validation with TypeScript</strong>:<br><code>type Validator<T> = (value: T) => string | null;<br><br>const emailValidator: Validator<string> = (email) => {<br>  return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email) <br>    ? null <br>    : 'Invalid email';<br>};</code><br><br>6. <strong>Typed form libraries</strong>: Use Formik or React Hook Form with TypeScript:<br><code>// With React Hook Form<br>const { register, handleSubmit, errors } = useForm<LoginForm>();<br><br>const onSubmit = (data: LoginForm) => {<br>  console.log(data); // Typed data<br>};</code><br><br>7. <strong>Controlled components</strong>:<br><code>const [form, setForm] = useState<LoginForm>({<br>  email: '',<br>  password: '',<br>  rememberMe: false<br>});<br><br>// Type-safe field updates<br>function updateField<K extends keyof LoginForm>(key: K, value: LoginForm[K]) {<br>  setForm(prev => ({ ...prev, [key]: value }));<br>}</code>",
      },
      {
        text: 'How do you organize types in a large React TypeScript project?',
        answer:
          "Organizing types in large React TypeScript projects:<br><br>1. <strong>Dedicated types files</strong>:<br>- <code>src/types/index.ts</code> - Export all types<br>- <code>src/types/user.ts</code> - Domain-specific types<br>- <code>src/types/api.ts</code> - API related types<br><br>2. <strong>Co-locate with components</strong>:<br>- <code>src/components/Button/Button.tsx</code><br>- <code>src/components/Button/Button.types.ts</code><br><br>3. <strong>Barrel exports</strong> for easier imports:<br><code>// types/index.ts<br>export * from './user';<br>export * from './api';<br>export * from './forms';</code><br><br>4. <strong>Type namespacing</strong> to avoid conflicts:<br><code>// user.ts<br>export namespace User {<br>  export interface Profile { /* ... */ }<br>  export interface Settings { /* ... */ }<br>}</code><br><br>5. <strong>Feature-based organization</strong>:<br><code>src/<br>  features/<br>    users/<br>      types.ts<br>      components/<br>      hooks/</code><br><br>6. <strong>Shared types</strong> for cross-cutting concerns:<br><code>src/types/common.ts</code> for pagination, filters, etc.<br><br>7. <strong>Type composition</strong> over inheritance:<br><code>type UserWithRoles = User & { roles: string[] };</code><br><br>8. <strong>Use type imports</strong> for better organization:<br><code>import type { User } from 'types';</code><br><br>9. <strong>Follow consistent naming conventions</strong>:<br>- Interfaces: PascalCase (UserProps)<br>- Type aliases: PascalCase (FormState)<br>- Generic type parameters: PascalCase single letters or descriptive (T, TData)<br><br>10. <strong>Document complex types</strong> with JSDoc comments.",
      },
    ],
  },
  {
    id: 'typescript-ecosystem',
    title: 'TypeScript Ecosystem and Libraries',
    questions: [
      {
        text: "How do you work with third-party libraries that don't have TypeScript definitions?",
        answer:
          "Working with untyped third-party libraries in TypeScript:<br><br>1. <strong>Check for DefinitelyTyped</strong>: First, check if types exist:<br><code>npm install --save-dev @types/library-name</code><br><br>2. <strong>Create module declaration files</strong>:<br><code>// src/types/library-name.d.ts<br>declare module 'library-name' {<br>  export function someFunction(param: string): number;<br>  export const someValue: string;<br>  export default class SomeClass {<br>    constructor(options?: { key?: string });<br>    methodName(param: string): void;<br>  }<br>}</code><br><br>3. <strong>Use any as a last resort</strong>:<br><code>import * as untyped from 'untyped-library';<br>const result = (untyped as any).someFunction();</code><br><br>4. <strong>Ambient declarations</strong> for global libraries:<br><code>// globals.d.ts<br>interface Window {<br>  externalLibrary: {<br>    doSomething(): void;<br>  }<br>}</code><br><br>5. <strong>Create partial types</strong> for just what you need:<br><code>interface PartialLibrary {<br>  // Define only the parts you're using<br>  methodA(x: number): string;<br>}</code><br><br>6. <strong>Contribute to DefinitelyTyped</strong>: Create types and submit them to the community.<br><br>7. <strong>Use declaration merging</strong> to augment existing modules:<br><code>import * as React from 'react';<br><br>declare module 'react' {<br>  interface HTMLAttributes<T> {<br>    customProp?: string;<br>  }<br>}</code><br><br>8. <strong>Use wildcard module declarations</strong> as a fallback:<br><code>// wildcard.d.ts<br>declare module '*';</code>",
      },
      {
        text: 'How do TypeScript and modern React features like hooks work together?',
        answer:
          "TypeScript and modern React hooks work together very well:<br><br>1. <strong>useState with type inference</strong>:<br><code>// Type inference works automatically<br>const [count, setCount] = useState(0); // number<br>const [user, setUser] = useState<User | null>(null);</code><br><br>2. <strong>useEffect with dependencies</strong>:<br><code>// TypeScript checks dependencies array<br>useEffect(() => {<br>  document.title = `Count: ${count}`;<br>}, [count]); // TypeScript knows count is used</code><br><br>3. <strong>useReducer with discriminated unions</strong>:<br><code>type Action =<br>  | { type: 'increment'; amount: number }<br>  | { type: 'decrement'; amount: number };<br><br>const [state, dispatch] = useReducer((state, action: Action) => {<br>  switch (action.type) {<br>    case 'increment':<br>      return { count: state.count + action.amount };<br>    // TypeScript will error if not all cases handled<br>  }<br>}, { count: 0 });</code><br><br>4. <strong>useRef with proper typing</strong>:<br><code>// Typed refs for DOM elements<br>const inputRef = useRef<HTMLInputElement>(null);</code><br><br>5. <strong>Generic custom hooks</strong>:<br><code>function useFetch<T>(url: string) {<br>  const [data, setData] = useState<T | null>(null);<br>  // Implementation...<br>  return { data, loading, error };<br>}<br><br>// Usage<br>const { data } = useFetch<User>('/api/user');</code><br><br>6. <strong>useContext with type safety</strong>:<br><code>const UserContext = createContext<{ user: User | null }>(null!);<br><br>function useUser() {<br>  const context = useContext(UserContext);<br>  if (context === undefined) {<br>    throw new Error('useUser must be used within UserProvider');<br>  }<br>  return context;<br>}</code><br><br>7. <strong>useCallback with proper typing</strong>:<br><code>const handleClick = useCallback((id: number) => {<br>  console.log(`Clicked ${id}`);<br>}, []);</code><br><br>8. <strong>forwardRef typed properly</strong>:<br><code>const Input = forwardRef<HTMLInputElement, { label: string }>(<br>  (props, ref) => (<br>    <input ref={ref} {...props} /><br>  )<br>);</code>",
      },
      {
        text: 'What TypeScript-specific tools and libraries are useful for React development?',
        answer:
          "Helpful TypeScript tools and libraries for React development:<br><br>1. <strong>Type checking tools</strong>:<br>- <strong>ESLint</strong> with TypeScript plugins for static analysis<br>- <strong>typescript-eslint</strong> for TypeScript-specific linting<br>- <strong>TSLint</strong> (deprecated but still used in some projects)<br><br>2. <strong>Type utilities</strong>:<br>- <strong>utility-types</strong>: Additional utility types beyond TypeScript's built-ins<br>- <strong>type-fest</strong>: Collection of useful TypeScript types<br>- <strong>ts-toolbelt</strong>: Largest TypeScript type library<br><br>3. <strong>Testing libraries</strong>:<br>- <strong>@testing-library/react</strong> with TypeScript support<br>- <strong>jest</strong> with <strong>ts-jest</strong> for TypeScript testing<br>- <strong>@types/jest</strong> for Jest type definitions<br><br>4. <strong>Type-safe state management</strong>:<br>- <strong>Redux Toolkit</strong> with TypeScript support<br>- <strong>MobX</strong> with <strong>mobx-react</strong><br>- <strong>Zustand</strong> for minimalistic typed state<br>- <strong>Jotai/Recoil</strong> for atomic state management<br><br>5. <strong>Form libraries</strong>:<br>- <strong>React Hook Form</strong> with strong TypeScript support<br>- <strong>Formik</strong> with TypeScript integration<br>- <strong>Zod</strong> for schema validation<br><br>6. <strong>Type-safe styling</strong>:<br>- <strong>styled-components</strong> with typing<br>- <strong>emotion</strong> with TypeScript support<br>- <strong>tailwind-css</strong> with <strong>twin.macro</strong><br><br>7. <strong>Type-safe API clients</strong>:<br>- <strong>React Query</strong> for type-safe data fetching<br>- <strong>SWR</strong> with TypeScript<br>- <strong>axios</strong> with typed responses<br>- <strong>tRPC</strong> for end-to-end type safety<br><br>8. <strong>Code generators</strong>:<br>- <strong>GraphQL Code Generator</strong> for type-safe GraphQL<br>- <strong>OpenAPI Generator</strong> for API type generation<br>- <strong>PLOP</strong> for template-based code generation<br><br>9. <strong>Type-safe routing</strong>:<br>- <strong>React Router</strong> with TypeScript<br>- <strong>Next.js</strong> with TypeScript support<br>- <strong>TanStack Router</strong> for fully type-safe routing",
      },
      {
        text: "What is the difference between 'extends' and 'implements' in TypeScript and when would you use each with React?",
        answer:
          "The differences between 'extends' and 'implements' in TypeScript:<br><br>1. <strong>extends</strong>:<br>- Used for inheritance between classes or interfaces<br>- A derived class/interface inherits all members from base<br>- Can only extend one class but multiple interfaces<br>- Works with types, interfaces, and classes<br><br><code>// Interface extending interface<br>interface ButtonProps {<br>  label: string;<br>}<br><br>interface PrimaryButtonProps extends ButtonProps {<br>  primary: boolean;<br>}</code><br><br>2. <strong>implements</strong>:<br>- Used by classes to satisfy an interface contract<br>- Does not inherit implementation, only ensures structure<br>- Can implement multiple interfaces<br>- Only used with classes, not interfaces or types<br><br><code>// Class implementing interface<br>class Button implements ButtonProps {<br>  label: string;<br>  <br>  constructor(label: string) {<br>    this.label = label;<br>  }<br>}</code><br><br>3. <strong>Use extends when</strong>:<br>- Creating specialized prop interfaces<br><code>interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {<br>  label: string;<br>}</code><br>- Building on existing types<br><code>type LinkButtonProps = ButtonProps & { href: string };</code><br>- Creating specialized components<br><code>class PrimaryButton extends Button {<br>  render() {<br>    return <button className=\"primary\">{this.props.label}</button>;<br>  }<br>}</code><br><br>4. <strong>Use implements when</strong>:<br>- Ensuring class components satisfy a contract<br><code>class UserForm implements FormComponentProps {<br>  validateForm() { /* implementation */ }<br>  submitForm() { /* implementation */ }<br>}</code><br>- Creating components that must follow a pattern<br><code>class DataTable implements SortableComponent, FilterableComponent {<br>  // Must implement all methods from both interfaces<br>}</code>",
      },
      {
        text: 'How do you type GraphQL operations in a React TypeScript application?',
        answer:
          "Typing GraphQL operations in React with TypeScript:<br><br>1. <strong>GraphQL Code Generator</strong>:<br>- The most popular approach for auto-generating types<br>- Setup in a few steps:<br><code>npm install -D @graphql-codegen/cli @graphql-codegen/typescript<br>@graphql-codegen/typescript-operations @graphql-codegen/typescript-react-apollo</code><br>- Create config file (codegen.yml)<br>- Run codegen to generate types from schema/operations<br><br>2. <strong>Apollo Client with TypeScript</strong>:<br><code>import { gql, useQuery } from '@apollo/client';<br>import { GetUserQuery, GetUserQueryVariables } from './generated/graphql';<br><br>const GET_USER = gql`<br>  query GetUser($id: ID!) {<br>    user(id: $id) {<br>      id<br>      name<br>      email<br>    }<br>  }<br>`;<br><br>function UserProfile({ id }: { id: string }) {<br>  const { data, loading } = useQuery<GetUserQuery, GetUserQueryVariables>(<br>    GET_USER,<br>    { variables: { id } }<br>  );<br>}</code><br><br>3. <strong>URQL with TypeScript</strong>:<br><code>import { useQuery } from 'urql';<br>import { GetUserQuery, GetUserQueryVariables } from './generated/graphql';<br><br>function UserProfile({ id }: { id: string }) {<br>  const [result] = useQuery<GetUserQuery, GetUserQueryVariables>({<br>    query: GET_USER,<br>    variables: { id }<br>  });<br>}</code><br><br>4. <strong>Manual typing</strong> (without code generation):<br><code>interface User {<br>  id: string;<br>  name: string;<br>  email: string;<br>}<br><br>interface GetUserData {<br>  user: User;<br>}<br><br>interface GetUserVars {<br>  id: string;<br>}</code><br><br>5. <strong>Relay with TypeScript</strong>:<br>- Configure relay-compiler with TypeScript plugin<br>- Generated types integrate with Relay's APIs<br><br>6. <strong>React-Query with GraphQL</strong>:<br><code>import { useQuery } from 'react-query';<br><br>const fetchUser = async (id: string): Promise<User> => {<br>  const response = await fetch('/graphql', {<br>    method: 'POST',<br>    body: JSON.stringify({<br>      query: `query GetUser($id: ID!) {...}`,<br>      variables: { id }<br>    })<br>  });<br>  <br>  const json = await response.json();<br>  return json.data.user;<br>};<br><br>function UserProfile({ id }: { id: string }) {<br>  const { data } = useQuery<User, Error>(['user', id], () => fetchUser(id));<br>}</code>",
      },
    ],
  },
  {
    id: 'typescript-migration',
    title: 'Migrating to TypeScript in React Projects',
    questions: [
      {
        text: "What's the best approach to migrate an existing React JavaScript project to TypeScript?",
        answer:
          'Best approach to migrate a React JavaScript project to TypeScript:<br><br>1. <strong>Incremental migration</strong>:<br>- Add TypeScript to the project gradually<br>- Configure tsconfig.json to allow .js files<br>- Use the allowJs compiler option<br><code>npm install --save-dev typescript @types/react @types/react-dom</code><br><br>2. <strong>Setup configuration</strong>:<br><code>// tsconfig.json<br>{<br>  "compilerOptions": {<br>    "target": "es5",<br>    "lib": ["dom", "dom.iterable", "esnext"],<br>    "allowJs": true,  // Allow JavaScript files<br>    "skipLibCheck": true,<br>    "esModuleInterop": true,<br>    "allowSyntheticDefaultImports": true,<br>    "strict": true,<br>    "forceConsistentCasingInFileNames": true,<br>    "noFallthroughCasesInSwitch": true,<br>    "module": "esnext",<br>    "moduleResolution": "node",<br>    "resolveJsonModule": true,<br>    "isolatedModules": true,<br>    "noEmit": true,<br>    "jsx": "react-jsx"<br>  },<br>  "include": ["src"]<br>}</code><br><br>3. <strong>Migrating files</strong> in order:<br>- Start with utils and helper functions<br>- Create types for your data models<br>- Then move to components<br>- Rename files from .js/.jsx to .ts/.tsx<br><br>4. <strong>Type declaration files</strong>:<br>- Create a declarations.d.ts file for untyped modules<br><code>// declarations.d.ts<br>declare module \'*.svg\' {<br>  const content: any;<br>  export default content;<br>}</code><br><br>5. <strong>Add type annotations gradually</strong>:<br>- Start with typing props<br>- Move to state<br>- Add types to event handlers<br><br>6. <strong>Use tools to help</strong>:<br>- <strong>TypeScript Migration Utility</strong><br>- <strong>typescript-eslint</strong> for catching errors<br>- <strong>@ts-check</strong> comments before full conversion<br><br>7. <strong>Looser type-checking during migration</strong>:<br>- Use <strong>any</strong> initially where needed<br>- Add <strong>// @ts-ignore</strong> for troublesome spots<br>- Gradually improve types over time<br><br>8. <strong>Follow patterns</strong>:<br>- Use React.FC sparingly or avoid<br>- Prefer interface for props<br>- Use JSDoc comments to describe complex types',
      },
      {
        text: 'What are some common challenges when migrating from JavaScript to TypeScript in React applications?',
        answer:
          "Common challenges when migrating React apps to TypeScript:<br><br>1. <strong>Third-party libraries without types</strong>:<br>- Find @types/* packages or write declaration files<br>- Use the \"noImplicitAny\" option to catch missing types<br><br>2. <strong>Complex component props</strong>:<br>- Props that change shape based on other props<br>- Higher-order components with complex typing<br>- Use discriminated unions and conditional types<br><code>type ButtonProps =<br>  | { variant: 'text'; href: string }<br>  | { variant: 'button'; onClick: () => void };</code><br><br>3. <strong>Any type overuse</strong>:<br>- Temptation to use any to bypass TypeScript errors<br>- Instead, use unknown and proper type narrowing<br><br>4. <strong>React's ref system</strong>:<br>- Properly typing refs and forwardRef<br><code>const inputRef = useRef<HTMLInputElement>(null);</code><br><br>5. <strong>Redux/state management</strong>:<br>- Type store, actions, reducers, and selectors<br>- Add TypeScript middleware types<br><br>6. <strong>Children prop typing</strong>:<br>- Use ReactNode for flexible children<br>- Use more specific types for constrained children<br><code>interface Props {<br>  children: React.ReactNode; // Any renderable content<br>}</code><br><br>7. <strong>Event handlers</strong>:<br>- Properly typing DOM events<br><code>const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {<br>  // Type-safe access to e.target.value<br>};</code><br><br>8. <strong>Migrating class components</strong>:<br>- Typing state, props, and lifecycle methods<br><code>class Counter extends React.Component<Props, State> {<br>  // TypeScript knows the shape of this.props and this.state<br>}</code><br><br>9. <strong>API responses</strong>:<br>- Creating interfaces for API data<br>- Handling optional/nullable API fields<br><br>10. <strong>Developer resistance</strong>:<br>- Learning curve for TypeScript<br>- Initial decrease in development speed<br>- Gradual adoption and training help",
      },
    ],
  },
]
