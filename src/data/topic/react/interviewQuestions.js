export default [
  {
    id: 'react-fundamentals',
    title: 'React Fundamentals',
    questions: [
      {
        text: 'What is the difference between state and props in React?',
        answer:
          '<code>Props</code> (short for properties) and <code>state</code> are both plain JavaScript objects that hold information influencing the output of render, but they have different purposes:<br><br>1. <strong>Props</strong>:<br>- Passed from parent component to child components<br>- Immutable (read-only) within the component receiving them<br>- Used to customize child components upon creation<br>- Changes in props trigger re-renders<br>- Can have default values using defaultProps<br><br>2. <strong>State</strong>:<br>- Managed within the component itself<br>- Mutable - can be updated using <code>setState()</code> in class components or state updater function in hooks<br>- Used for data that changes over time/user interaction<br>- Should be kept as minimal as possible<br>- Changes in state trigger re-renders<br><br>Props flow down from parent to child (unidirectional data flow), while state is internal to components.',
      },
      {
        text: 'Explain the component lifecycle in React class components',
        answer:
          'React class components go through a series of lifecycle phases:<br><br><strong>Mounting Phase:</strong><br>1. <code>constructor()</code> - Initialize state and bind methods<br>2. <code>static getDerivedStateFromProps(props, state)</code> - Return updated state based on props<br>3. <code>render()</code> - Required method that returns React elements<br>4. <code>componentDidMount()</code> - Invoked after component is inserted into the DOM (ideal for API calls, subscriptions)<br><br><strong>Updating Phase:</strong><br>1. <code>static getDerivedStateFromProps(props, state)</code> - Same as in mounting<br>2. <code>shouldComponentUpdate(nextProps, nextState)</code> - Control whether component should re-render<br>3. <code>render()</code> - Same as in mounting<br>4. <code>getSnapshotBeforeUpdate(prevProps, prevState)</code> - Capture information before DOM updates<br>5. <code>componentDidUpdate(prevProps, prevState, snapshot)</code> - Operate on the DOM after update<br><br><strong>Unmounting Phase:</strong><br>1. <code>componentWillUnmount()</code> - Clean up (remove event listeners, cancel subscriptions)<br><br><strong>Error Handling:</strong><br>1. <code>static getDerivedStateFromError(error)</code> - Update state in response to an error<br>2. <code>componentDidCatch(error, info)</code> - Log error information',
      },
      {
        text: 'What are React Hooks and why were they introduced?',
        answer:
          "React Hooks are functions that let you use state and other React features in functional components without writing a class. Introduced in React 16.8, hooks were created to:<br><br>1. Reuse stateful logic between components without complex patterns like render props or HOCs<br>2. Split complex components into smaller functions based on related pieces (e.g., setting up a subscription or fetching data)<br>3. Use React features without classes, avoiding issues with JavaScript's <code>this</code> keyword<br>4. Avoid breaking changes while addressing these issues<br><br>Common built-in hooks include:<br>- <code>useState</code> - Add state to functional components<br>- <code>useEffect</code> - Perform side effects (similar to lifecycle methods)<br>- <code>useContext</code> - Access React context<br>- <code>useReducer</code> - Manage more complex state with a reducer<br>- <code>useRef</code> - Create a mutable reference<br>- <code>useMemo</code> - Memoize expensive calculations<br>- <code>useCallback</code> - Memoize functions<br><br>Hooks follow specific rules: they must be called at the top level (not inside loops, conditions, or nested functions) and only called from React function components or custom hooks.",
      },
      {
        text: 'Why is it important to use keys when rendering lists in React?',
        answer:
          "Keys are special string attributes that help React identify which items have changed, been added, or been removed in lists. They're important because:<br><br>1. They help React maintain component state when the list changes<br>2. They enable efficient updates by allowing React to reuse DOM elements instead of rebuilding the entire list<br>3. They prevent bugs related to component state when items are reordered<br><br>Without keys, React would regenerate every element in the list when it changes, which is inefficient. With keys, React can identify exactly which items changed.<br><br>Best practices for keys:<br>- Keys should be stable, predictable, and unique among siblings<br>- Use item IDs from your data as keys when possible: <code>{items.map(item => <li key={item.id}>{item.name}</li>)}</code><br>- Avoid using array indices as keys when the list can reorder, as this can cause performance issues and bugs<br>- Keys only need to be unique among siblings, not globally<br>- Keys are not passed as props to components (use a different prop name if you need that value)",
      },
      {
        text: 'Explain the concept of JSX in React',
        answer:
          "JSX (JavaScript XML) is a syntax extension for JavaScript that looks similar to HTML but is used with React to describe what the UI should look like.<br><br>Key characteristics of JSX:<br><br>1. It allows you to write HTML-like code in JavaScript files<br>2. JSX is transpiled to regular JavaScript by tools like Babel before being executed by browsers<br>3. Behind the scenes, JSX is converted to <code>React.createElement()</code> calls<br><br>For example, this JSX:<br><code>&lt;div className=\"container\"&gt;Hello {name}&lt;/div&gt;</code><br><br>Gets compiled to:<br><code>React.createElement('div', {className: 'container'}, 'Hello ', name)</code><br><br>Important JSX rules and features:<br>- JSX uses <code>className</code> instead of <code>class</code> (since class is a reserved word in JavaScript)<br>- JSX uses camelCase property naming convention (e.g., <code>onClick</code> instead of <code>onclick</code>)<br>- Curly braces <code>{}</code> are used to embed JavaScript expressions<br>- JSX elements can be assigned to variables, passed as arguments, and returned from functions<br>- Adjacent JSX elements must be wrapped in an enclosing tag or fragment (<code>&lt;&gt;&lt;/&gt;</code>)<br>- Self-closing tags must end with <code>/&gt;</code> (e.g., <code>&lt;img /&gt;</code>)",
      },
      {
        text: 'What are controlled and uncontrolled components in React?',
        answer:
          "In React forms, there are two approaches to handling input elements: controlled and uncontrolled components.<br><br><strong>Controlled Components:</strong><br>- Form data is handled by React component state<br>- Input values are set via props and changed via event handlers<br>- Every state mutation has an associated handler function<br>- More explicit and React-centric approach<br><br>Example of controlled component:<br><code>function Form() {<br>  const [value, setValue] = useState('');<br>  const handleChange = (e) => setValue(e.target.value);<br>  return &lt;input value={value} onChange={handleChange} /&gt;;<br>}</code><br><br><strong>Uncontrolled Components:</strong><br>- Form data is handled by the DOM itself<br>- Use refs to get form values from the DOM when needed<br>- Doesn't require an event handler for every state update<br>- Simpler for basic forms or when integrating with non-React code<br><br>Example of uncontrolled component:<br><code>function Form() {<br>  const inputRef = useRef(null);<br>  const handleSubmit = () => {<br>    console.log(inputRef.current.value);<br>  };<br>  return (<br>    &lt;&gt;<br>      &lt;input defaultValue=\"default\" ref={inputRef} /&gt;<br>      &lt;button onClick={handleSubmit}&gt;Submit&lt;/button&gt;<br>    &lt;/&gt;<br>  );<br>}</code><br><br>Controlled components are generally preferred in React applications because they make state more predictable and easier to debug.",
      },
    ],
  },
  {
    id: 'state-management',
    title: 'State Management and Data Flow',
    questions: [
      {
        text: 'What is the Context API and when would you use it?',
        answer:
          "The Context API provides a way to share values like themes, user data, or other global state between components without explicitly passing props through every level of the component tree (prop drilling).<br><br>Components of the Context API:<br>1. <code>React.createContext</code>: Creates a context object with optional default value<br>2. <code>Context.Provider</code>: Component that allows consuming components to subscribe to context changes<br>3. <code>Context.Consumer</code>: Component that subscribes to context changes (older approach)<br>4. <code>useContext</code> hook: Simpler way to consume context in functional components<br><br>Example usage:<br><code>// Creating context<br>const ThemeContext = React.createContext('light');<br><br>// Provider in parent component<br>function App() {<br>  const [theme, setTheme] = useState('light');<br>  return (<br>    &lt;ThemeContext.Provider value={theme}&gt;<br>      &lt;Layout /&gt;<br>      &lt;button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}&gt;<br>        Toggle Theme<br>      &lt;/button&gt;<br>    &lt;/ThemeContext.Provider&gt;<br>  );<br>}<br><br>// Consumer in nested component<br>function Button() {<br>  const theme = useContext(ThemeContext);<br>  return &lt;button className={theme}&gt;Themed Button&lt;/button&gt;;<br>}</code><br><br>Use Context when:<br>- Data needs to be accessed by many components at different nesting levels<br>- Passing props would create verbose and difficult-to-maintain code<br>- You have global state like user authentication, themes, or preferences<br><br>Context is not optimized for high-frequency updates and shouldn't replace all component communication or state management libraries for complex applications.",
      },
      {
        text: 'Explain Redux and its core principles',
        answer:
          "Redux is a predictable state container for JavaScript applications, commonly used with React for managing application state. It's based on three fundamental principles:<br><br>1. <strong>Single Source of Truth</strong>: The entire application state is stored in a single JavaScript object called the store<br>2. <strong>State is Read-Only</strong>: The only way to change state is to emit an action (a plain JavaScript object describing what happened)<br>3. <strong>Changes are Made with Pure Functions</strong>: Reducers are pure functions that take the previous state and an action and return the next state<br><br>Core Redux concepts:<br><br>- <code>Store</code>: Holds the state, allows access via <code>getState()</code>, updates via <code>dispatch(action)</code>, and registers listeners via <code>subscribe()</code><br>- <code>Actions</code>: Plain objects with a <code>type</code> property that describe a state change<br>- <code>Reducers</code>: Pure functions that specify how state changes in response to actions<br>- <code>Dispatch</code>: The method used to send actions to the store<br>- <code>Middleware</code>: Extends Redux with custom functionality (e.g., logging, async actions)<br><br>Basic Redux flow:<br>1. User interaction triggers dispatch of an action<br>2. Redux store passes the current state and action to the reducer<br>3. Reducer calculates and returns the new state<br>4. Store updates its state and notifies all subscribers<br>5. UI re-renders based on the new state<br><br>Modern Redux typically uses Redux Toolkit to reduce boilerplate and follow best practices.",
      },
      {
        text: 'What are custom hooks in React and how would you create one?',
        answer:
          'Custom hooks are JavaScript functions that start with <code>use</code> and may call other hooks. They allow you to extract component logic into reusable functions, share stateful logic between components, and keep components cleaner.<br><br>Guidelines for creating custom hooks:<br>1. Start the function name with <code>use</code> (e.g., <code>useFetch</code>, <code>useForm</code>)<br>2. Call other hooks inside your custom hook<br>3. Return values that components will use<br>4. Follow the same rules of hooks (call only at the top level, only from React functions)<br><br>Example of a custom hook for form handling:<br><code>function useForm(initialValues = {}) {<br>  const [values, setValues] = useState(initialValues);<br>  const [errors, setErrors] = useState({});<br><br>  // Handle input changes<br>  const handleChange = (e) => {<br>    const { name, value } = e.target;<br>    setValues(prevValues => ({<br>      ...prevValues,<br>      [name]: value<br>    }));<br>  };<br><br>  // Reset form<br>  const resetForm = () => {<br>    setValues(initialValues);<br>    setErrors({});<br>  };<br><br>  return {<br>    values,<br>    errors,<br>    setErrors,<br>    handleChange,<br>    resetForm<br>  };<br>}</code><br><br>Using the custom hook in a component:<br><code>function SignupForm() {<br>  const { values, errors, handleChange, setErrors, resetForm } = useForm({<br>    email: \'\',<br>    password: \'\'<br>  });<br><br>  const handleSubmit = (e) => {<br>    e.preventDefault();<br>    // Form validation and submission logic<br>  };<br><br>  return (<br>    &lt;form onSubmit={handleSubmit}&gt;<br>      &lt;input<br>        name="email"<br>        value={values.email}<br>        onChange={handleChange}<br>      /&gt;<br>      {errors.email && &lt;p&gt;{errors.email}&lt;/p&gt;}<br>      {/* More fields */}<br>      &lt;button type="submit"&gt;Sign Up&lt;/button&gt;<br>    &lt;/form&gt;<br>  );<br>}</code>',
      },
      {
        text: 'Explain the difference between useCallback, useMemo, and React.memo',
        answer:
          "These three features help optimize React performance, but they serve different purposes:<br><br><strong><code>useCallback</code></strong>:<br>- Memoizes callback functions between renders<br>- Returns a memoized version of the callback that only changes if one of the dependencies has changed<br>- Primary use: Preventing unnecessary re-renders when passing callbacks to optimized child components that rely on reference equality<br>- Syntax: <code>const memoizedCallback = useCallback(() => { doSomething(a, b) }, [a, b]);</code><br><br><strong><code>useMemo</code></strong>:<br>- Memoizes computed values between renders<br>- Returns a memoized value that only recalculates when one of the dependencies has changed<br>- Primary use: Avoiding expensive calculations on every render<br>- Syntax: <code>const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);</code><br><br><strong><code>React.memo</code></strong>:<br>- A higher-order component that memoizes component renders<br>- Component only re-renders if its props change (performs a shallow comparison by default)<br>- Primary use: Preventing re-renders when a component's props are the same<br>- Syntax: <code>const MemoizedComponent = React.memo(SomeComponent);</code><br>- Can accept a custom comparison function as second argument<br><br>When to use each:<br>- Use <code>React.memo</code> for components that render often with the same props<br>- Use <code>useCallback</code> when passing callbacks to optimized child components<br>- Use <code>useMemo</code> for expensive calculations or when creating objects that would trigger re-renders in child components<br><br>Note that premature optimization can make code more complex without meaningful performance benefits. Use these optimizations when you have identified actual performance issues.",
      },
      {
        text: 'What is prop drilling and how can it be avoided?',
        answer:
          'Prop drilling (also called "threading") is the process of passing props through multiple levels of nested components that don\'t need those props but only pass them down to deeper components that do need them.<br><br>Problems with prop drilling:<br>1. Makes code harder to maintain and read<br>2. Creates tight coupling between components<br>3. Makes refactoring more difficult<br>4. Results in unnecessary re-renders when passed props change<br><br>Strategies to avoid prop drilling:<br><br>1. <strong>React Context API</strong><br>- Create a context to share values that would otherwise need to be passed through many levels<br>- Components can consume the context directly without props<br><code>const UserContext = React.createContext();<br>&lt;UserContext.Provider value={userData}&gt;<br>  &lt;App /&gt;<br>&lt;/UserContext.Provider&gt;</code><br><br>2. <strong>Redux or other state management libraries</strong><br>- Centralize state and let components access what they need<br>- Components connect directly to the global store<br><br>3. <strong>Component Composition</strong><br>- Pass JSX as children or props instead of data<br>- Lets parent components control layout while child components control rendering<br><code>&lt;Layout&gt;<br>  &lt;Sidebar&gt;<br>    &lt;UserProfile user={user} /&gt;<br>  &lt;/Sidebar&gt;<br>&lt;/Layout&gt;</code><br><br>4. <strong>Custom hooks</strong><br>- Extract common logic into custom hooks<br>- Components can use the hook directly to access shared functionality<br><br>5. <strong>Render props pattern</strong><br>- Pass a function as a prop that returns JSX<br>- Child component calls this function with its internal state<br><code>&lt;DataProvider render={data => (<br>  &lt;DisplayComponent data={data} /&gt;<br>)} /&gt;</code>',
      },
      {
        text: 'Explain the useEffect hook and its cleanup mechanism',
        answer:
          "The <code>useEffect</code> hook allows you to perform side effects in functional components, such as data fetching, subscriptions, manual DOM manipulations, logging, etc.<br><br>Basic syntax:<br><code>useEffect(() => {<br>  // Side effect code<br>  <br>  // Optional cleanup function<br>  return () => {<br>    // Cleanup code<br>  };<br>}, [dependencies]);</code><br><br>Key characteristics:<br>1. Runs after every render by default<br>2. Can specify dependencies to control when the effect runs<br>3. Can return a cleanup function<br><br>Dependency array behaviors:<br>- Empty array <code>[]</code>: Effect runs only on mount and cleanup runs only on unmount (similar to componentDidMount and componentWillUnmount)<br>- With dependencies <code>[a, b]</code>: Effect runs on mount and whenever any dependency changes<br>- No dependency array: Effect runs after every render<br><br>The cleanup mechanism is crucial for preventing memory leaks. It's used for:<br>1. Cancelling subscriptions (event listeners, timers, observables)<br>2. Invalidating asynchronous operations that are no longer relevant<br>3. Releasing resources<br><br>Example with cleanup:<br><code>useEffect(() => {<br>  // Set up subscription/event listener<br>  const subscription = someAPI.subscribe(data => {<br>    setResult(data);<br>  });<br>  <br>  // Cleanup function<br>  return () => {<br>    // Unsubscribe when component unmounts or before effect runs again<br>    subscription.unsubscribe();<br>  };<br>}, [someAPI]);</code><br><br>Common patterns:<br>- Data fetching with cleanup for abandoned requests<br>- Setting up and removing event listeners<br>- Starting and stopping timers<br>- Managing WebSocket or other real-time connections",
      },
    ],
  },
  {
    id: 'advanced-patterns',
    title: 'Advanced React Patterns and TypeScript',
    questions: [
      {
        text: 'What are Higher-Order Components (HOCs) and how do they work?',
        answer:
          "A Higher-Order Component (HOC) is an advanced pattern in React that takes a component and returns a new component with enhanced functionality. HOCs are a way to reuse component logic across your application.<br><br>Key characteristics of HOCs:<br>1. Pure function with zero side-effects<br>2. Takes a component as input and returns an enhanced version of it<br>3. Doesn't modify the input component but composes it<br>4. Can add props, state, or behavior to the wrapped component<br><br>Basic structure of an HOC:<br><code>function withFeature(WrappedComponent) {<br>  return function EnhancedComponent(props) {<br>    // Add extra props or logic<br>    const extraProps = { feature: 'value' };<br>    <br>    // Return wrapped component with extra props<br>    return &lt;WrappedComponent {...props} {...extraProps} /&gt;;<br>  };<br>}</code><br><br>Common use cases:<br>- Authentication/authorization checks<br>- Data fetching and loading states<br>- Tracking analytics<br>- Adding styling or layout<br>- Handling cross-cutting concerns<br><br>Example of an HOC that tracks component mounting time:<br><code>function withTiming(Component) {<br>  return function WithTiming(props) {<br>    useEffect(() => {<br>      const start = performance.now();<br>      return () => {<br>        const end = performance.now();<br>        console.log(`${Component.name} mounted for ${end - start}ms`);<br>      };<br>    }, []);<br>    <br>    return &lt;Component {...props} /&gt;;<br>  };<br>}</code><br><br>HOCs have largely been replaced by Hooks in modern React, but they're still useful in certain scenarios, especially when working with class components or when you need to wrap entire components rather than just adding behavior.",
      },
      {
        text: 'Explain the Render Props pattern in React',
        answer:
          "The Render Props pattern is a technique for sharing code between React components using a prop whose value is a function that returns a React element. This function lets the component share its internal state or behavior with other components.<br><br>Key characteristics:<br>1. A component receives a function as a prop<br>2. This function returns React elements<br>3. The component calls this function in its render method, passing it data<br>4. This enables component logic reuse without inheritance<br><br>Basic structure:<br><code>// Component using render props<br>function DataProvider({ render }) {<br>  const [data, setData] = useState([]);<br>  <br>  useEffect(() => {<br>    fetchData().then(result => setData(result));<br>  }, []);<br>  <br>  // Call the render prop function with data<br>  return render(data);<br>}</code><br><br>Usage:<br><code>&lt;DataProvider<br>  render={data => (<br>    &lt;div&gt;<br>      {data.map(item => (<br>        &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;<br>      ))}<br>    &lt;/div&gt;<br>  )}<br>/&gt;</code><br><br>Alternative using children as a function (also a render prop):<br><code>&lt;DataProvider&gt;<br>  {data => (<br>    &lt;div&gt;{data.map(item => (&lt;div key={item.id}&gt;{item.name}&lt;/div&gt;))}&lt;/div&gt;<br>  )}<br>&lt;/DataProvider&gt;</code><br><br>Benefits of render props:<br>- Explicit data flow (you can see what data is being passed)<br>- Composition-friendly<br>- Avoids HOC naming collisions<br>- Doesn't require class components<br><br>Common use cases:<br>- Sharing state or behavior between components<br>- Implementing mouse position tracking<br>- Form handling utilities<br>- Access to context or application state<br><br>Like HOCs, render props have been largely replaced by hooks in modern React for simpler cases, but they remain useful when you need to share complex rendering logic.",
      },
      {
        text: 'What are Error Boundaries in React and how do you implement them?',
        answer:
          "Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire component tree.<br><br>Key characteristics:<br>1. Only catch errors in the components below them in the tree<br>2. Do not catch errors in event handlers, asynchronous code, or their own code<br>3. Must be implemented as class components<br>4. Require at least one of the error lifecycle methods<br><br>Implementing an Error Boundary:<br><code>class ErrorBoundary extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = { hasError: false, error: null };<br>  }<br><br>  // Update state when an error occurs<br>  static getDerivedStateFromError(error) {<br>    return { hasError: true, error };<br>  }<br><br>  // Log error information<br>  componentDidCatch(error, errorInfo) {<br>    console.error('Error caught by boundary:', error, errorInfo);<br>    // You could also log to an error reporting service here<br>  }<br><br>  render() {<br>    if (this.state.hasError) {<br>      // Render fallback UI<br>      return (<br>        &lt;div className=\"error-container\"&gt;<br>          &lt;h2&gt;Something went wrong.&lt;/h2&gt;<br>          &lt;details&gt;<br>            &lt;summary&gt;Error Details&lt;/summary&gt;<br>            &lt;p&gt;{this.state.error?.toString()}&lt;/p&gt;<br>          &lt;/details&gt;<br>          &lt;button onClick={() => this.setState({ hasError: false, error: null })}&gt;<br>            Try Again<br>          &lt;/button&gt;<br>        &lt;/div&gt;<br>      );<br>    }<br><br>    return this.props.children;<br>  }<br>}</code><br><br>Using Error Boundaries:<br><code>&lt;ErrorBoundary&gt;<br>  &lt;ComponentThatMightError /&gt;<br>&lt;/ErrorBoundary&gt;</code><br><br>Best practices:<br>1. Place error boundaries strategically in your application (not just at the root)<br>2. Use different fallback UIs for different parts of your app<br>3. Use error boundaries with suspense boundaries<br>4. Don't try to recover from every error - some should crash the application<br>5. Consider creating different error boundaries for different types of errors<br><br>Note that as of React 18, there is experimental support for using error boundaries with the <code>useErrorBoundary</code> hook, but for production applications, class components are still the recommended approach.",
      },
      {
        text: 'How does TypeScript improve React development?',
        answer:
          "TypeScript enhances React development in several key ways:<br><br>1. <strong>Type Safety</strong>:<br>- Catches type-related errors during development instead of runtime<br>- Validates prop types at compile time<br>- Prevents common errors like undefined properties or incorrect prop types<br><br>2. <strong>Better Developer Experience</strong>:<br>- Provides intelligent code completion and IntelliSense<br>- Improves refactoring capabilities<br>- Makes code navigation easier<br>- Makes component APIs self-documenting<br><br>3. <strong>Type Definitions for Props</strong>:<br><code>interface UserProfileProps {<br>  user: {<br>    id: number;<br>    name: string;<br>    email: string;<br>  };<br>  isEditable?: boolean;<br>  onUpdate: (userId: number, data: Partial&lt;User&gt;) => void;<br>}</code><br><br>4. <strong>Type-Safe Hooks</strong>:<br><code>// Typed state<br>const [user, setUser] = useState&lt;User | null&gt;(null);<br><br>// Typed callbacks<br>const handleSubmit = useCallback&lt;FormSubmitHandler&gt;((values) => {<br>  // TypeScript knows the shape of values<br>}, []);</code><br><br>5. <strong>Discriminated Unions for State Management</strong>:<br><code>type RequestState&lt;T&gt; =<br>  | { status: 'idle' }<br>  | { status: 'loading' }<br>  | { status: 'success'; data: T }<br>  | { status: 'error'; error: Error };</code><br><br>6. <strong>Generic Components</strong>:<br><code>function List&lt;T&gt;({ items, renderItem }: {<br>  items: T[];<br>  renderItem: (item: T) => React.ReactNode;<br>}) {<br>  return (<br>    &lt;ul&gt;<br>      {items.map((item, index) => (<br>        &lt;li key={index}&gt;{renderItem(item)}&lt;/li&gt;<br>      ))}<br>    &lt;/ul&gt;<br>  );<br>}</code><br><br>7. <strong>Type-Safe Context</strong>:<br><code>const UserContext = createContext&lt;{<br>  user: User | null;<br>  login: (credentials: Credentials) => Promise&lt;void&gt;;<br>  logout: () => void;<br>} | undefined&gt;(undefined);</code><br><br>8. <strong>Better Integration with Libraries</strong>:<br>- Most React libraries provide TypeScript definitions<br>- Type checking for imported components and hooks<br><br>TypeScript does add some overhead in terms of writing more code and learning curve, but the benefits typically outweigh the costs for larger or long-lived applications.",
      },
      {
        text: 'What are the Compound Components pattern and when would you use it?',
        answer:
          'The Compound Components pattern is an advanced React pattern where multiple components work together to form a cohesive unit with shared state and behavior. It\'s similar to how HTML elements like <code>&lt;select&gt;</code> and <code>&lt;option&gt;</code> work together.<br><br>Key characteristics:<br>1. A parent component manages shared state and behavior<br>2. Child components access the parent\'s state via context<br>3. Components are designed to be used together<br>4. API is more declarative and flexible<br><br>Example implementation of a tabs component:<br><code>// Create context for tabs state<br>const TabsContext = createContext(null);<br><br>// Parent component<br>function Tabs({ children, defaultIndex = 0 }) {<br>  const [activeIndex, setActiveIndex] = useState(defaultIndex);<br>  <br>  // Value to be shared with child components<br>  const contextValue = { activeIndex, setActiveIndex };<br>  <br>  return (<br>    &lt;TabsContext.Provider value={contextValue}&gt;<br>      &lt;div className="tabs"&gt;{children}&lt;/div&gt;<br>    &lt;/TabsContext.Provider&gt;<br>  );<br>}<br><br>// Tab list component<br>function TabList({ children }) {<br>  return &lt;div className="tab-list"&gt;{children}&lt;/div&gt;;<br>}<br><br>// Individual tab component<br>function Tab({ children, index }) {<br>  const { activeIndex, setActiveIndex } = useContext(TabsContext);<br>  const isActive = activeIndex === index;<br>  <br>  return (<br>    &lt;button<br>      className={`tab ${isActive ? \'active\' : \'\'}`}<br>      onClick={() => setActiveIndex(index)}<br>    &gt;<br>      {children}<br>    &lt;/button&gt;<br>  );<br>}<br><br>// Tab panel component<br>function TabPanel({ children, index }) {<br>  const { activeIndex } = useContext(TabsContext);<br>  <br>  if (activeIndex !== index) return null;<br>  <br>  return &lt;div className="tab-panel"&gt;{children}&lt;/div&gt;;<br>}</code><br><br>Usage of the compound component:<br><code>&lt;Tabs defaultIndex={0}&gt;<br>  &lt;TabList&gt;<br>    &lt;Tab index={0}&gt;Profile&lt;/Tab&gt;<br>    &lt;Tab index={1}&gt;Settings&lt;/Tab&gt;<br>    &lt;Tab index={2}&gt;Notifications&lt;/Tab&gt;<br>  &lt;/TabList&gt;<br>  <br>  &lt;TabPanel index={0}&gt;<br>    &lt;h2&gt;Profile Content&lt;/h2&gt;<br>    &lt;p&gt;Profile details here...&lt;/p&gt;<br>  &lt;/TabPanel&gt;<br>  <br>  &lt;TabPanel index={1}&gt;<br>    &lt;h2&gt;Settings Content&lt;/h2&gt;<br>    &lt;p&gt;Settings details here...&lt;/p&gt;<br>  &lt;/TabPanel&gt;<br>  <br>  &lt;TabPanel index={2}&gt;<br>    &lt;h2&gt;Notifications Content&lt;/h2&gt;<br>    &lt;p&gt;Notifications details here...&lt;/p&gt;<br>  &lt;/TabPanel&gt;<br>&lt;/Tabs&gt;</code><br><br>Use the Compound Components pattern when:<br>1. Components need to share implicit state<br>2. You want to give users flexibility in component composition<br>3. You need an intuitive API for complex component interactions<br>4. The component has multiple related parts that work together<br><br>Common examples include tabs, menus, accordions, and form components like select/option.',
      },
    ],
  },
  {
    id: 'ecosystem-performance',
    title: 'React Ecosystem and Performance',
    questions: [
      {
        text: 'Explain React Router and its key components',
        answer:
          'React Router is a standard library for routing in React applications, enabling navigation between different components and controlling what is displayed on the screen as the URL changes.<br><br>Key components in React Router v6:<br><br>1. <code>&lt;BrowserRouter&gt;</code>:<br>- Uses HTML5 history API to sync UI with the URL<br>- Most common router for modern web applications<br>- Example: <code>&lt;BrowserRouter&gt;&lt;App /&gt;&lt;/BrowserRouter&gt;</code><br><br>2. <code>&lt;Routes&gt;</code> and <code>&lt;Route&gt;</code>:<br>- <code>&lt;Routes&gt;</code> acts as a container for route definitions<br>- <code>&lt;Route&gt;</code> defines a mapping between a URL path and a component<br>- Example: <code>&lt;Routes&gt;&lt;Route path="/users" element={&lt;Users /&gt;} /&gt;&lt;/Routes&gt;</code><br><br>3. <code>&lt;Link&gt;</code> and <code>&lt;NavLink&gt;</code>:<br>- <code>&lt;Link&gt;</code> creates navigation links without page reloads<br>- <code>&lt;NavLink&gt;</code> is a special Link that adds "active" styling when the path matches<br>- Example: <code>&lt;Link to="/about"&gt;About&lt;/Link&gt;</code><br><br>4. <code>&lt;Outlet&gt;</code>:<br>- Used for nested routes to render child route components<br>- Example: <code>&lt;Route path="/products" element={&lt;Products /&gt;&gt;<br>  &lt;Route path=":id" element={&lt;ProductDetail /&gt;} /&gt;<br>&lt;/Route&gt;</code><br><br>5. <code>&lt;Navigate&gt;</code>:<br>- Performs programmatic navigation when rendered<br>- Example: <code>&lt;Navigate to="/login" replace /&gt;</code><br><br>6. Hooks:<br>- <code>useParams</code>: Access route parameters<br>- <code>useNavigate</code>: Programmatic navigation<br>- <code>useLocation</code>: Access the current location<br>- <code>useSearchParams</code>: Access and modify query parameters<br><br>Route parameters example:<br><code>// Route definition<br>&lt;Route path="/products/:id" element={&lt;ProductDetail /&gt;} /&gt;<br><br>// In ProductDetail component<br>function ProductDetail() {<br>  const { id } = useParams();<br>  // Now you can fetch product with this id<br>}</code><br><br>Common patterns:<br>1. Protected routes for authentication<br>2. Layouts with nested routes<br>3. Lazy loading with React.lazy and Suspense<br>4. Handling 404 pages with a wildcard route<br>5. Using URL parameters for dynamic content',
      },
      {
        text: 'What is the difference between client-side rendering (CSR) and server-side rendering (SSR) in React?',
        answer:
          'Client-Side Rendering (CSR) and Server-Side Rendering (SSR) are two approaches to rendering React applications, each with different tradeoffs:<br><br><strong>Client-Side Rendering (CSR):</strong><br>- The browser receives minimal HTML and a JavaScript bundle<br>- React builds the UI in the browser after JavaScript loads<br>- The initial page is typically a nearly empty HTML shell<br>- Example: Create React App<br><br>Pros of CSR:<br>- Faster subsequent page navigation after initial load<br>- Reduced server load<br>- Clear separation between frontend and backend<br>- Better for highly interactive applications<br><br>Cons of CSR:<br>- Slower initial page load and time to interactive<br>- Poorer SEO (search engines may not execute JavaScript)<br>- Potentially worse user experience on slow devices/connections<br>- More client-side processing<br><br><strong>Server-Side Rendering (SSR):</strong><br>- The server renders the React components to HTML<br>- The browser receives fully rendered HTML<br>- JavaScript then "hydrates" the HTML to make it interactive<br>- Example: Next.js, Remix<br><br>Pros of SSR:<br>- Faster initial page load and first contentful paint<br>- Better SEO as search engines see complete content<br>- Better performance on low-powered devices<br>- Improved user experience for content-focused sites<br><br>Cons of SSR:<br>- Higher server load and complexity<br>- Slower navigation between pages (unless using hybrid approaches)<br>- More complex build and deployment process<br>- Potential issues with third-party libraries<br><br><strong>Hybrid Approaches:</strong><br>- <strong>Static Site Generation (SSG)</strong>: Pre-renders pages at build time (Next.js, Gatsby)<br>- <strong>Incremental Static Regeneration (ISR)</strong>: Regenerates static pages periodically or on-demand<br>- <strong>Partial Hydration</strong>: Hydrates only interactive parts of the page<br>- <strong>Progressive Hydration</strong>: Hydrates components in order of priority<br><br>The best approach depends on your application\'s needs, with content-focused sites often benefiting from SSR/SSG and highly interactive applications sometimes preferring CSR.',
      },
      {
        text: 'How would you optimize the performance of a React application?',
        answer:
          "Optimizing React performance involves several strategies:<br><br>1. <strong>Component Optimization</strong>:<br>- Use <code>React.memo</code> for functional components to prevent unnecessary re-renders<br>- Implement <code>shouldComponentUpdate</code> or extend <code>PureComponent</code> for class components<br>- Use <code>useMemo</code> to memoize expensive calculations<br>- Use <code>useCallback</code> to memoize event handlers passed to child components<br><br>2. <strong>State Management Optimization</strong>:<br>- Keep state as local as possible<br>- Split large state objects into smaller, more focused ones<br>- Use state normalization techniques for complex data<br>- Consider using immutable data structures<br><br>3. <strong>Rendering Optimization</strong>:<br>- Virtualize long lists with react-window or react-virtualized<br>- Use code splitting with <code>React.lazy</code> and <code>Suspense</code><br>- Implement proper keys for list items<br>- Avoid anonymous functions in render methods<br><br>4. <strong>Bundle Optimization</strong>:<br>- Set up tree shaking in your build process<br>- Use dynamic imports for code splitting<br>- Analyze your bundle with tools like webpack-bundle-analyzer<br>- Optimize images and assets<br><br>5. <strong>Network Optimization</strong>:<br>- Implement proper caching strategies<br>- Use CDNs for static assets<br>- Consider server-side rendering or static site generation for faster initial load<br>- Implement data prefetching for anticipated user actions<br><br>6. <strong>Effective React Patterns</strong>:<br>- Lifting content up to avoid re-rendering entire trees<br>- Using portals for modals and tooltips<br>- Implementing windowing for large data sets<br>- Using web workers for CPU-intensive tasks<br><br>7. <strong>Development Practices</strong>:<br>- Use React DevTools Profiler to identify performance bottlenecks<br>- Set up performance monitoring in production<br>- Use React's built-in Profiler API for custom measurements<br>- Consider using the <code>why-did-you-render</code> library during development<br><br>8. <strong>React 18 Features</strong> (if applicable):<br>- Use Concurrent Mode features<br>- Implement Suspense for data fetching<br>- Use automatic batching of state updates<br><br>Always measure before optimizing, as premature optimization can lead to more complex, harder-to-maintain code without significant benefits.",
      },
      {
        text: 'What are the best practices for handling API requests in React?',
        answer:
          "Best practices for handling API requests in React:<br><br>1. <strong>Use Hooks for Data Fetching</strong>:<br>- Create custom hooks to encapsulate fetch logic<br>- Example: <code>useFetch</code>, <code>useAPI</code>, or <code>useResource</code> hooks<br><code>function useFetch(url) {<br>  const [data, setData] = useState(null);<br>  const [loading, setLoading] = useState(true);<br>  const [error, setError] = useState(null);<br>  <br>  useEffect(() => {<br>    let isMounted = true;<br>    <br>    async function fetchData() {<br>      try {<br>        setLoading(true);<br>        const response = await fetch(url);<br>        if (!response.ok) throw new Error(response.statusText);<br>        const json = await response.json();<br>        if (isMounted) {<br>          setData(json);<br>          setError(null);<br>        }<br>      } catch (err) {<br>        if (isMounted) setError(err.message);<br>      } finally {<br>        if (isMounted) setLoading(false);<br>      }<br>    }<br>    <br>    fetchData();<br>    <br>    return () => { isMounted = false; };<br>  }, [url]);<br>  <br>  return { data, loading, error };<br>}</code><br><br>2. <strong>Handle Loading, Error, and Success States</strong>:<br>- Always track and display these states<br>- Consider using a discriminated union type for state management<br><code>function ProductPage({ id }) {<br>  const { data, loading, error } = useFetch(`/api/products/${id}`);<br>  <br>  if (loading) return &lt;LoadingSpinner /&gt;;<br>  if (error) return &lt;ErrorMessage message={error} /&gt;;<br>  <br>  return &lt;ProductDetails product={data} /&gt;;<br>}</code><br><br>3. <strong>Cancellation and Cleanup</strong>:<br>- Cancel pending requests when components unmount<br>- Use AbortController or custom solutions<br>- Track mounted state in useEffect<br><br>4. <strong>Cache and Data Management</strong>:<br>- Use data fetching libraries like React Query or SWR<br>- Implement proper caching strategies<br>- Handle re-fetching and invalidation<br><code>import { useQuery } from 'react-query';<br><br>function Products() {<br>  const { data, error, isLoading } = useQuery('products', fetchProducts);<br>  // Rest of component<br>}</code><br><br>5. <strong>Separation of Concerns</strong>:<br>- Separate API service layer from components<br>- Create API client with axios, fetch, or similar<br>- Define reusable API functions<br><br>6. <strong>Security Considerations</strong>:<br>- Sanitize inputs and validate server responses<br>- Handle authentication tokens properly<br>- Implement proper CORS handling<br><br>7. <strong>Error Handling</strong>:<br>- Implement global error handling<br>- Use error boundaries for unexpected errors<br>- Log errors for monitoring<br><br>8. <strong>Performance Optimizations</strong>:<br>- Implement request debouncing for search inputs<br>- Use pagination for large data sets<br>- Consider data prefetching for anticipated user actions",
      },
      {
        text: 'What testing strategies would you implement for a React application?',
        answer:
          "A comprehensive testing strategy for React applications should include multiple types of tests:<br><br>1. <strong>Unit Testing</strong>:<br>- Test individual components in isolation<br>- Focus on component logic, state changes, and props handling<br>- Use Jest with React Testing Library or Enzyme<br>- Example:<br><code>test('Button calls onClick handler', () => {<br>  const handleClick = jest.fn();<br>  render(&lt;Button onClick={handleClick}&gt;Click Me&lt;/Button&gt;);<br>  fireEvent.click(screen.getByText('Click Me'));<br>  expect(handleClick).toHaveBeenCalledTimes(1);<br>});</code><br><br>2. <strong>Integration Testing</strong>:<br>- Test how components work together<br>- Verify component interactions and data flow<br>- Test form submissions, API interactions, and state updates<br>- Example:<br><code>test('Login form submits data correctly', async () => {<br>  const mockLogin = jest.fn();<br>  render(&lt;LoginForm onSubmit={mockLogin} /&gt;);<br>  <br>  userEvent.type(screen.getByLabelText(/username/i), 'testuser');<br>  userEvent.type(screen.getByLabelText(/password/i), 'password123');<br>  userEvent.click(screen.getByRole('button', { name: /login/i }));<br>  <br>  await waitFor(() => {<br>    expect(mockLogin).toHaveBeenCalledWith({<br>      username: 'testuser',<br>      password: 'password123'<br>    });<br>  });<br>});</code><br><br>3. <strong>End-to-End Testing</strong>:<br>- Test complete user workflows<br>- Use tools like Cypress, Playwright, or Selenium<br>- Verify application behavior from user's perspective<br>- Example (Cypress):<br><code>describe('Authentication flow', () => {<br>  it('allows user to login and access protected page', () => {<br>    cy.visit('/login');<br>    cy.get('[name=username]').type('testuser');<br>    cy.get('[name=password]').type('password123');<br>    cy.get('button[type=submit]').click();<br>    cy.url().should('include', '/dashboard');<br>    cy.contains('Welcome, testuser');<br>  });<br>});</code><br><br>4. <strong>Snapshot Testing</strong>:<br>- Capture component output and compare to previous versions<br>- Detect unintended changes in component rendering<br>- Example:<br><code>test('Button renders correctly', () => {<br>  const tree = renderer.create(<br>    &lt;Button variant=\"primary\"&gt;Click Me&lt;/Button&gt;<br>  ).toJSON();<br>  expect(tree).toMatchSnapshot();<br>});</code><br><br>5. <strong>Visual Regression Testing</strong>:<br>- Test visual appearance of components<br>- Use tools like Percy, Chromatic, or Applitools<br>- Detect unwanted visual changes<br><br>6. <strong>Performance Testing</strong>:<br>- Test rendering performance and bundle size<br>- Use React DevTools Profiler or Lighthouse<br>- Create performance budgets<br><br>7. <strong>Accessibility Testing</strong>:<br>- Ensure app is accessible to all users<br>- Use tools like axe-core, react-axe, or jest-axe<br>- Example:<br><code>test('Form is accessible', async () => {<br>  const { container } = render(&lt;LoginForm /&gt;);<br>  const results = await axe(container);<br>  expect(results).toHaveNoViolations();<br>});</code><br><br>8. <strong>Test Organization Tips</strong>:<br>- Follow the Arrange-Act-Assert pattern<br>- Use test-data-id attributes for test selection<br>- Group tests by features or components<br>- Focus on testing behavior, not implementation<br>- Mock external dependencies",
      },
      {
        text: 'What is React Context API and when would you use it instead of Redux?',
        answer:
          "The React Context API provides a way to share values like themes, user data, or other application state between components without explicitly passing props through every level of the component tree.<br><br><strong>How Context API works:</strong><br>1. Create a context with <code>React.createContext(defaultValue)</code><br>2. Provide values with a <code>Context.Provider</code> component<br>3. Consume values using either:<br>   - <code>useContext</code> hook (in functional components)<br>   - <code>Context.Consumer</code> (in class components)<br>   - <code>static contextType</code> (in class components, limited to one context)<br><br>Basic example:<br><code>// Create context<br>const ThemeContext = React.createContext('light');<br><br>// Provider<br>function App() {<br>  const [theme, setTheme] = useState('light');<br>  <br>  return (<br>    &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;<br>      &lt;MainContent /&gt;<br>    &lt;/ThemeContext.Provider&gt;<br>  );<br>}<br><br>// Consumer with useContext<br>function ThemedButton() {<br>  const { theme, setTheme } = useContext(ThemeContext);<br>  <br>  return (<br>    &lt;button<br>      className={`btn-${theme}`}<br>      onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}<br>    &gt;<br>      Toggle Theme<br>    &lt;/button&gt;<br>  );<br>}</code><br><br><strong>When to use Context API instead of Redux:</strong><br><br>Use Context API when:<br>1. Your application has simple shared state requirements<br>2. Your state doesn't change frequently<br>3. You have a small to medium-sized application<br>4. The state is mostly static (themes, user info, preferences)<br>5. You want to avoid the additional dependencies of Redux<br>6. You're sharing non-global state between a subset of components<br><br>Use Redux when:<br>1. Your application has complex state with frequent updates<br>2. You need centralized state management with strict update patterns<br>3. You need time-travel debugging, middleware, and other advanced features<br>4. Your application is large with many developers working on it<br>5. You need state persistence and synchronization features<br>6. You prefer having a standardized state management approach<br><br>You can also use both together: Context API for less frequently changing data (theme, auth) and Redux for complex application state.<br><br>For simpler applications, you might consider alternatives like:<br>- Use multiple, more focused contexts instead of one global state<br>- Use React Query or SWR for server state management<br>- Use Zustand, Jotai, or Recoil for simpler state management",
      },
    ],
  },
  {
    id: 'deployment-best-practices',
    title: 'Deployment and Best Practices',
    questions: [
      {
        text: 'Explain the different ways to deploy a React application',
        answer:
          'There are several approaches to deploy a React application to production:<br><br>1. <strong>Static Site Hosting</strong>:<br>- Build React app with <code>npm run build</code> to generate static files<br>- Deploy files to static hosting services<br>- Options: Netlify, Vercel, GitHub Pages, AWS S3 + CloudFront, Firebase Hosting<br>- Best for: Client-side rendered apps without server requirements<br>- Example process:<br>  <code>npm run build</code><br>  Deploy the <code>build</code> folder to hosting service<br><br>2. <strong>Traditional Web Servers</strong>:<br>- Build React app and serve static files from web server<br>- Configure server for SPA routing (redirect 404s to index.html)<br>- Options: Apache, Nginx, IIS<br>- Best for: Integration with existing server infrastructure<br>- Example Nginx configuration:<br>  <code>location / {<br>    root /var/www/react-app/build;<br>    try_files $uri $uri/ /index.html;<br>  }</code><br><br>3. <strong>Containerization</strong>:<br>- Create Docker container with built React app and web server<br>- Deploy to container orchestration platforms<br>- Options: Kubernetes, AWS ECS, Google Cloud Run, Azure Container Instances<br>- Best for: Consistent deployment environments and microservices<br>- Example Dockerfile:<br>  <code>FROM nginx:alpine<br>COPY build/ /usr/share/nginx/html/<br>COPY nginx.conf /etc/nginx/conf.d/default.conf<br>EXPOSE 80<br>CMD ["nginx", "-g", "daemon off;"]</code><br><br>4. <strong>Serverless Platforms</strong>:<br>- Build app and deploy to serverless platforms<br>- Handles scaling automatically<br>- Options: Vercel, Netlify, AWS Amplify, Firebase Hosting<br>- Best for: JAMstack applications with serverless functions<br><br>5. <strong>Full-Stack JavaScript Platforms</strong>:<br>- For apps with Node.js backends<br>- Deploy entire application to platforms supporting both frontend and backend<br>- Options: Heroku, DigitalOcean App Platform, Render<br>- Best for: Full-stack JavaScript applications<br><br>6. <strong>Server-Side Rendering (SSR) Deployment</strong>:<br>- For Next.js, Remix, or custom SSR React apps<br>- Requires a Node.js environment<br>- Options: Vercel, Netlify, AWS Elastic Beanstalk, Heroku<br>- Best for: Applications benefiting from SSR<br><br>7. <strong>CI/CD Integration</strong>:<br>- Set up automated build and deployment pipelines<br>- Run tests before deployment<br>- Options: GitHub Actions, GitLab CI, Jenkins, CircleCI, Travis CI<br>- Best for: Team environments with frequent releases<br><br>Deployment considerations:<br>- Environment variables management<br>- HTTPS setup<br>- CDN configuration<br>- Build optimization<br>- Monitoring and error tracking',
      },
      {
        text: 'What are the key security considerations for React applications?',
        answer:
          "Security considerations for React applications include:<br><br>1. <strong>Cross-Site Scripting (XSS) Protection</strong>:<br>- React automatically escapes values embedded in JSX<br>- Avoid using <code>dangerouslySetInnerHTML</code> when possible<br>- If needed, sanitize HTML with libraries like DOMPurify<br>- Don't use <code>eval()</code> or similar functions with user input<br><code>// Bad:<br>function Comment({ userContent }) {<br>  return &lt;div dangerouslySetInnerHTML={{ __html: userContent }} /&gt;;<br>}<br><br>// Better:<br>import DOMPurify from 'dompurify';<br>function SafeComment({ userContent }) {<br>  return &lt;div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(userContent) }} /&gt;;<br>}</code><br><br>2. <strong>Cross-Site Request Forgery (CSRF) Protection</strong>:<br>- Use anti-CSRF tokens for API requests<br>- Implement proper authentication with HTTP-only cookies<br>- Consider using the SameSite cookie attribute<br><br>3. <strong>Secure State Management</strong>:<br>- Don't store sensitive data in localStorage or sessionStorage (vulnerable to XSS)<br>- Use HTTP-only cookies for authentication tokens<br>- Implement proper token validation and expiration<br><br>4. <strong>API Security</strong>:<br>- Validate all input on the server-side<br>- Implement proper authentication and authorization<br>- Use HTTPS for all API requests<br>- Add rate limiting to prevent brute force attacks<br><br>5. <strong>Dependency Management</strong>:<br>- Regularly update dependencies to patch vulnerabilities<br>- Use tools like npm audit, Snyk, or Dependabot<br>- Be cautious with third-party packages<br>- Set up security scanning in CI/CD pipeline<br><code>npm audit fix</code><br><br>6. <strong>Client-Side Routing Security</strong>:<br>- Don't rely solely on client-side routes for access control<br>- Implement proper authorization checks on the server<br>- Use protected routes pattern in React Router<br><br>7. <strong>Content Security Policy (CSP)</strong>:<br>- Implement CSP headers to prevent XSS and data injection<br>- Be cautious with inline scripts and styles<br>- Use nonce or hash-based CSP when needed<br><br>8. <strong>Error Handling</strong>:<br>- Don't expose sensitive information in error messages<br>- Implement global error boundaries<br>- Log errors securely<br><br>9. <strong>Environment Variables</strong>:<br>- Never expose API keys directly in React code<br>- Use environment variables with proper prefixing (REACT_APP_ for Create React App)<br>- Keep sensitive operations server-side<br><br>10. <strong>Code Splitting Considerations</strong>:<br>- Ensure protected routes' components aren't bundled with public routes<br>- Be cautious with dynamic imports of user-controlled paths<br><br>11. <strong>Security Headers</strong>:<br>- Implement proper security headers (X-XSS-Protection, X-Content-Type-Options, etc.)<br>- Use tools like Helmet.js for Express backends",
      },
      {
        text: 'How would you optimize a React application for production?',
        answer:
          'Optimizing a React application for production involves multiple strategies:<br><br>1. <strong>Build Optimization</strong>:<br>- Enable production mode (<code>NODE_ENV=production</code>)<br>- Minimize and bundle code with webpack or other build tools<br>- Split vendor code into separate chunks<br>- Use tree shaking to eliminate dead code<br>- Optimize CSS (minimize, purge unused styles)<br>- Configure proper caching strategies<br><br>2. <strong>Code Splitting</strong>:<br>- Use dynamic imports for route-based splitting<br><code>const Dashboard = React.lazy(() => import(\'./Dashboard\'));</code><br>- Implement component-level code splitting for large components<br>- Use <code>React.Suspense</code> for loading states<br><code>&lt;Suspense fallback={&lt;Spinner /&gt;}&gt;<br>  &lt;Dashboard /&gt;<br>&lt;/Suspense&gt;</code><br><br>3. <strong>Asset Optimization</strong>:<br>- Compress and optimize images (WebP, responsive images)<br>- Implement lazy loading for below-the-fold images<br>- Use font-display property for text rendering<br>- Minimize SVGs and consider using sprites<br>- Preload critical assets<br><code>&lt;link rel="preload" href="/fonts/main.woff2" as="font" /&gt;</code><br><br>4. <strong>Performance Optimization</strong>:<br>- Implement memoization with <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code><br>- Virtualize long lists with react-window or react-virtualized<br>- Avoid unnecessary re-renders through proper component structure<br>- Optimize component state to avoid rendering bottlenecks<br>- Use the React DevTools Profiler to identify performance issues<br><br>5. <strong>Resource Delivery</strong>:<br>- Use a CDN for static assets<br>- Implement proper HTTP caching headers<br>- Enable Brotli or gzip compression<br>- Consider using service workers for offline support<br>- Implement resource hints (dns-prefetch, preconnect)<br><code>&lt;link rel="preconnect" href="https://api.example.com" /&gt;</code><br><br>6. <strong>Server Optimization</strong> (for SSR):<br>- Implement component caching<br>- Use streaming rendering when possible<br>- Optimize critical rendering path<br>- Consider hybrid approaches (SSG + client hydration)<br><br>7. <strong>Runtime Optimization</strong>:<br>- Avoid memory leaks with proper cleanup<br>- Debounce or throttle expensive operations<br>- Implement thread offloading with web workers for CPU-intensive tasks<br>- Lazy initialize expensive objects<br><br>8. <strong>Monitoring and Analytics</strong>:<br>- Implement error tracking (Sentry, LogRocket)<br>- Set up performance monitoring (Lighthouse, WebVitals)<br>- Track and optimize Core Web Vitals<br>- Use RUM (Real User Monitoring) for performance insights<br><code>import { getCLS, getFID, getLCP } from \'web-vitals\';<br><br>function sendToAnalytics(metric) {<br>  // Send the metric to your analytics service<br>}<br><br>getCLS(sendToAnalytics);<br>getFID(sendToAnalytics);<br>getLCP(sendToAnalytics);</code><br><br>9. <strong>SEO Optimization</strong>:<br>- Implement server-side rendering or pre-rendering for better SEO<br>- Add proper meta tags and structured data<br>- Ensure accessibility for better rankings<br>- Create a sitemap and robots.txt',
      },
      {
        text: 'What is progressive rendering and how can it be implemented in React?',
        answer:
          "Progressive rendering is a technique to improve perceived performance by prioritizing the display of essential content as quickly as possible, then gradually loading and rendering less critical parts of the page.<br><br>Key concepts of progressive rendering in React:<br><br>1. <strong>Code Splitting</strong>:<br>- Split application code into smaller chunks loaded on demand<br>- Use <code>React.lazy()</code> for component-level code splitting<br>- Example:<br><code>const HomePage = React.lazy(() => import('./HomePage'));<br>const AboutPage = React.lazy(() => import('./AboutPage'));<br><br>function App() {<br>  return (<br>    &lt;Suspense fallback={&lt;Loading /&gt;}&gt;<br>      &lt;Routes&gt;<br>        &lt;Route path=\"/\" element={&lt;HomePage /&gt;} /&gt;<br>        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;<br>      &lt;/Routes&gt;<br>    &lt;/Suspense&gt;<br>  );<br>}</code><br><br>2. <strong>Progressive Hydration</strong>:<br>- Prioritize hydration of interactive elements<br>- Delay hydration of less important components<br>- Example with a custom solution:<br><code>function ProgressiveHydration({ children, importance = 'low' }) {<br>  const [hydrated, setHydrated] = useState(importance === 'high');<br>  <br>  useEffect(() => {<br>    if (!hydrated) {<br>      // Use requestIdleCallback for low importance components<br>      if (importance === 'low' && 'requestIdleCallback' in window) {<br>        window.requestIdleCallback(() => setHydrated(true));<br>      } else {<br>        // Use setTimeout for medium importance<br>        setTimeout(() => setHydrated(true), 0);<br>      }<br>    }<br>  }, [hydrated, importance]);<br>  <br>  return (<br>    &lt;&gt;<br>      {hydrated ? children : &lt;div dangerouslySetInnerHTML={{ __html: '' }} /&gt;}<br>    &lt;/&gt;<br>  );<br>}</code><br><br>3. <strong>Lazy Loading Images and Media</strong>:<br>- Load images only when they're about to enter viewport<br>- Use IntersectionObserver API or libraries like react-lazyload<br>- Example:<br><code>import { LazyLoadImage } from 'react-lazy-load-image-component';<br><br>function Gallery() {<br>  return (<br>    &lt;div&gt;<br>      {images.map(img => (<br>        &lt;LazyLoadImage<br>          key={img.id}<br>          src={img.url}<br>          effect=\"blur\"<br>          threshold={300}<br>          placeholderSrc={img.thumbnail}<br>        /&gt;<br>      ))}<br>    &lt;/div&gt;<br>  );<br>}</code><br><br>4. <strong>Skeleton Screens</strong>:<br>- Show layout placeholders while content loads<br>- Improves perceived performance<br>- Example:<br><code>function ProductCard({ product, loading }) {<br>  if (loading) {<br>    return &lt;ProductCardSkeleton /&gt;;<br>  }<br>  <br>  return (<br>    &lt;div className=\"product-card\"&gt;<br>      &lt;img src={product.image} alt={product.name} /&gt;<br>      &lt;h2&gt;{product.name}&lt;/h2&gt;<br>      &lt;p&gt;{product.price}&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>}</code><br><br>5. <strong>Prioritized Content Rendering</strong>:<br>- Render above-the-fold content first<br>- Defer rendering of below-the-fold content<br>- Example with Intersection Observer:<br><code>function DeferredRender({ children }) {<br>  const [shouldRender, setShouldRender] = useState(false);<br>  const ref = useRef(null);<br>  <br>  useEffect(() => {<br>    const observer = new IntersectionObserver(<br>      ([entry]) => {<br>        if (entry.isIntersecting) {<br>          setShouldRender(true);<br>          observer.disconnect();<br>        }<br>      },<br>      { rootMargin: '200px' }<br>    );<br>    <br>    if (ref.current) {<br>      observer.observe(ref.current);<br>    }<br>    <br>    return () => observer.disconnect();<br>  }, []);<br>  <br>  return (<br>    &lt;div ref={ref}&gt;<br>      {shouldRender ? children : &lt;div style={{ height: '100px' }} /&gt;}<br>    &lt;/div&gt;<br>  );<br>}</code><br><br>6. <strong>Data Streaming</strong> (SSR):<br>- Stream HTML to the browser in chunks<br>- Enable earlier rendering of available parts<br>- Frameworks like Next.js and Remix support this",
      },
      {
        text: 'What are React design patterns and anti-patterns?',
        answer:
          "Common React design patterns and anti-patterns:<br><br><strong>Design Patterns:</strong><br><br>1. <strong>Component Composition</strong>:<br>- Compose components to build complex UIs<br>- Favor composition over inheritance<br>- Use children props to create flexible components<br><code>&lt;Card&gt;<br>  &lt;Card.Header&gt;Title&lt;/Card.Header&gt;<br>  &lt;Card.Body&gt;Content&lt;/Card.Body&gt;<br>  &lt;Card.Footer&gt;Actions&lt;/Card.Footer&gt;<br>&lt;/Card&gt;</code><br><br>2. <strong>Container/Presentational Pattern</strong>:<br>- Separate data fetching (containers) from rendering (presentational)<br>- Containers manage state and logic<br>- Presentational components focus on UI<br><code>// Container<br>function UserListContainer() {<br>  const [users, setUsers] = useState([]);<br>  <br>  useEffect(() => {<br>    fetchUsers().then(data => setUsers(data));<br>  }, []);<br>  <br>  return &lt;UserList users={users} /&gt;;<br>}<br><br>// Presentational<br>function UserList({ users }) {<br>  return (<br>    &lt;ul&gt;<br>      {users.map(user => (<br>        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;<br>      ))}<br>    &lt;/ul&gt;<br>  );<br>}</code><br><br>3. <strong>Custom Hooks</strong>:<br>- Extract reusable logic into custom hooks<br>- Share stateful logic between components<br>- Keep components cleaner and focused<br><br>4. <strong>Compound Components</strong>:<br>- Components that work together using shared implicit state<br>- Provides flexible and declarative APIs<br>- Components share state via Context<br><br>5. <strong>Render Props</strong>:<br>- Component takes a function prop that returns elements<br>- Share state or behavior between components<br>- Provide greater control over rendering<br><br>6. <strong>State Reducer Pattern</strong>:<br>- Give consumers control over internal state logic<br>- Similar to Redux reducers but component-scoped<br>- Provides inversion of control<br><br><strong>Anti-Patterns:</strong><br><br>1. <strong>Prop Drilling</strong>:<br>- Passing props through many levels of components<br>- Makes code harder to maintain<br>- Better alternatives: Context API, state management libraries<br><br>2. <strong>Huge Component Files</strong>:<br>- Components with too many responsibilities<br>- Difficult to understand and maintain<br>- Solution: Break into smaller, focused components<br><br>3. <strong>Using Indexes as Key Props</strong>:<br>- Can cause rendering issues when list order changes<br>- Impacts performance and can lead to bugs<br>- Solution: Use stable, unique IDs<br><code>// Bad<br>{items.map((item, index) => (<br>  &lt;Item key={index} data={item} /&gt;<br>))}<br><br>// Good<br>{items.map(item => (<br>  &lt;Item key={item.id} data={item} /&gt;<br>))}</code><br><br>4. <strong>Overusing State</strong>:<br>- Using state for derived values<br>- Solution: Calculate values during render<br><code>// Bad<br>const [fullName, setFullName] = useState('');<br>useEffect(() => {<br>  setFullName(\\`\\${firstName} \\${lastName}\\`);<br>}, [firstName, lastName]);<br><br>// Good<br>const fullName = \\`\\${firstName} \\${lastName}\\`;</code><br><br>5. <strong>Direct DOM Manipulation</strong>:<br>- Bypassing React's lifecycle with direct DOM updates<br>- Solution: Use refs when necessary, but prefer React's declarative approach<br><br>6. <strong>Not Memoizing Dependencies</strong>:<br>- Creating new function references in every render<br>- Causes unnecessary re-renders<br>- Solution: Use useCallback and useMemo<br><br>7. <strong>Ignoring Component Lifecycle</strong>:<br>- Not cleaning up side effects<br>- Memory leaks from event listeners, timers, subscriptions<br>- Solution: Proper useEffect cleanup<br><br>8. <strong>Premature Optimization</strong>:<br>- Adding complexity before performance issues exist<br>- Solution: Measure first, then optimize as needed",
      },
    ],
  },
]
